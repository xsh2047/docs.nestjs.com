"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassLikeExportDoc = exports.HeritageInfo = void 0;
/* tslint:disable:no-bitwise */
/* tslint:disable:max-classes-per-file */
const typescript_1 = require("typescript");
const getDeclarationTypeText_1 = require("../services/TsParser/getDeclarationTypeText");
const getDecorators_1 = require("../services/TsParser/getDecorators");
const getTypeText_1 = require("../services/TsParser/getTypeText");
const ContainerExportDoc_1 = require("./ContainerExportDoc");
class HeritageInfo {
    constructor(type, text) {
        this.type = type;
        this.text = text;
    }
}
exports.HeritageInfo = HeritageInfo;
/**
 * Interfaces and classes are "class-like", in that they can contain members, heritage, type parameters and decorators
 */
class ClassLikeExportDoc extends ContainerExportDoc_1.ContainerExportDoc {
    constructor(host, moduleDoc, symbol, declaration, aliasSymbol) {
        super(host, moduleDoc, symbol, declaration, aliasSymbol);
        this.decorators = (0, getDecorators_1.getDecorators)(this.declaration);
        this.extendsClauses = [];
        this.implementsClauses = [];
        this.descendants = [];
        this.typeParams = this.computeTypeParams();
        this.computeHeritageClauses();
        this.addAliases();
    }
    computeTypeParams() {
        if (this.symbol.members) {
            const typeParams = [];
            this.symbol.members.forEach((member) => {
                var _a;
                if (member.getFlags() & typescript_1.SymbolFlags.TypeParameter) {
                    (_a = member.declarations) === null || _a === void 0 ? void 0 : _a.forEach(d => typeParams.push((0, getDeclarationTypeText_1.getDeclarationTypeText)(d)));
                }
            });
            if (typeParams.length)
                return `<${typeParams.join(', ')}>`;
        }
        return '';
    }
    addAliases() {
        if (this.typeParams) {
            // Make sure duplicate aliases aren't created, so "Ambiguous link" warnings are prevented
            this.aliases.push(this.name + this.typeParams);
            this.aliases.push(this.moduleDoc.id + '/' + this.name + this.typeParams);
        }
    }
    computeHeritageClauses() {
        // Collect up all the heritage clauses from each declaration
        // (interfaces can have multiple declarations, which are merged, each with their own heritage)
        this.symbol.getDeclarations().forEach(declaration => {
            getHeritage(declaration).forEach(clause => {
                // Now process these clauses to find each "extends" and "implements" clause
                if (clause.token === typescript_1.SyntaxKind.ExtendsKeyword) {
                    this.extendsClauses = this.extendsClauses.concat(clause.types.map(heritageType => new HeritageInfo(heritageType, (0, getTypeText_1.getTypeText)(heritageType))));
                }
                else {
                    this.implementsClauses = this.implementsClauses.concat(clause.types.map(heritageType => new HeritageInfo(heritageType, (0, getTypeText_1.getTypeText)(heritageType))));
                }
            });
        });
    }
}
exports.ClassLikeExportDoc = ClassLikeExportDoc;
function getHeritage(declaration) {
    return declaration.heritageClauses || [];
}
//# sourceMappingURL=ClassLikeExportDoc.js.map