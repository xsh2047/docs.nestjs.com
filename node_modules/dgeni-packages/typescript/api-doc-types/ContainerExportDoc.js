"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerExportDoc = void 0;
/* tslint:disable:no-bitwise */
const typescript_1 = require("typescript");
const getAccessibility_1 = require("../services/TsParser/getAccessibility");
const ExportDoc_1 = require("./ExportDoc");
const MethodMemberDoc_1 = require("./MethodMemberDoc");
const PropertyMemberDoc_1 = require("./PropertyMemberDoc");
const MethodMemberFlags = typescript_1.SymbolFlags.Method |
    typescript_1.SymbolFlags.Signature |
    typescript_1.SymbolFlags.Constructor |
    typescript_1.SymbolFlags.Accessor;
const PropertyMemberFlags = typescript_1.SymbolFlags.Property | typescript_1.SymbolFlags.EnumMember;
const MembersToIgnoreFlags = typescript_1.SymbolFlags.Prototype | typescript_1.SymbolFlags.TypeParameter | typescript_1.SymbolFlags.Constructor;
/**
 * This document represents things that contain members such as classes, enums and interfaces.
 *
 * Although such things can have multiple mergeable declarations, we consider them as a single doc.
 * So such documents are not OverloadableExport docs.
 */
class ContainerExportDoc extends ExportDoc_1.ExportDoc {
    constructor() {
        super(...arguments);
        this.members = [];
    }
    getMemberDocs(members, hidePrivateMembers) {
        const memberDocs = [];
        members.forEach(member => {
            const flags = member.getFlags();
            // Ignore the prototype export
            if (flags & MembersToIgnoreFlags)
                return;
            // Ignore private members, if configured to do so
            if (hidePrivateMembers && (0, getAccessibility_1.getAccessibility)(member.valueDeclaration) === 'private')
                return;
            const overloads = [];
            let memberDoc = null;
            let getAccessorDeclaration = null;
            let setAccessorDeclaration = null;
            for (const declaration of member.getDeclarations()) {
                if (flags & MethodMemberFlags) {
                    if (declaration.kind === typescript_1.SyntaxKind.GetAccessor) {
                        getAccessorDeclaration = declaration;
                    }
                    else if (declaration.kind === typescript_1.SyntaxKind.SetAccessor) {
                        setAccessorDeclaration = declaration;
                    }
                    else if (declaration.body) {
                        // This is the "real" declaration of the method
                        memberDoc = new MethodMemberDoc_1.MethodMemberDoc(this.host, this, member, declaration, overloads);
                    }
                    else {
                        // This is an overload signature of the method
                        overloads.push(new MethodMemberDoc_1.MethodMemberDoc(this.host, this, member, declaration, overloads));
                    }
                }
                else if (flags & PropertyMemberFlags) {
                    memberDoc = new PropertyMemberDoc_1.PropertyMemberDoc(this.host, this, member, declaration, null, null);
                }
                else {
                    throw new Error(`Unknown member type for member ${member.name}`);
                }
            }
            // If at least one of the declarations was an accessor then the whole member is a property.
            if (getAccessorDeclaration || setAccessorDeclaration) {
                memberDoc = new PropertyMemberDoc_1.PropertyMemberDoc(this.host, this, member, null, getAccessorDeclaration, setAccessorDeclaration);
            }
            // If there is no member doc then we are in an interface or abstract class and we just take the first overload
            // as the primary one.
            memberDocs.push(memberDoc || overloads.shift());
        });
        return memberDocs;
    }
}
exports.ContainerExportDoc = ContainerExportDoc;
//# sourceMappingURL=ContainerExportDoc.js.map