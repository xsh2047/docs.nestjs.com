"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TsParser = exports.getAccessibility = exports.getContent = exports.getExportDocType = void 0;
/* tslint:disable:no-bitwise */
const typescript_1 = require("typescript");
const CustomCompilerHost_1 = require("./CustomCompilerHost");
var getExportDocType_1 = require("./getExportDocType");
Object.defineProperty(exports, "getExportDocType", { enumerable: true, get: function () { return getExportDocType_1.getExportDocType; } });
var getContent_1 = require("./getContent");
Object.defineProperty(exports, "getContent", { enumerable: true, get: function () { return getContent_1.getContent; } });
var getAccessibility_1 = require("./getAccessibility");
Object.defineProperty(exports, "getAccessibility", { enumerable: true, get: function () { return getAccessibility_1.getAccessibility; } });
class TsParser {
    constructor(log) {
        this.log = log;
        // These are the extension that we should consider when trying to load a module
        // During migration from Traceur, there is a mix of `.ts`, `.es6` and `.js` (atScript)
        // files in the project and the TypeScript compiler only looks for `.ts` files when trying
        // to load imports.
        this.extensions = ['.ts', '.js'];
        // The options for the TS compiler
        this.options = {
            allowNonTsExtensions: true,
            charset: 'utf8',
            newLine: typescript_1.NewLineKind.LineFeed,
        };
    }
    parse(fileNames, baseDir) {
        // "Compile" a program from the given module filenames, to get hold of a
        // typeChecker that can be used to interrogate the modules, exports and so on.
        const host = new CustomCompilerHost_1.CustomCompilerHost(this.options, baseDir, this.extensions, this.log);
        const program = (0, typescript_1.createProgram)(fileNames, this.options, host);
        const typeChecker = program.getTypeChecker();
        // Create an array of module symbols for each file we were given
        const moduleSymbols = [];
        fileNames.forEach(fileName => {
            const sourceFile = program.getSourceFile(fileName);
            if (!sourceFile) {
                throw new Error('Invalid source file: ' + fileName);
            }
            else if (!sourceFile.symbol) {
                // Some files contain only a comment and no actual module code
                this.log.warn('No module code found in ' + fileName);
            }
            else {
                moduleSymbols.push(sourceFile.symbol);
            }
        });
        moduleSymbols.forEach(tsModule => {
            // The type checker has a nice helper function that returns an array of Symbols representing the exports for a given module
            tsModule.exportArray = typeChecker.getExportsOfModule(tsModule);
            tsModule.exportArray.forEach(moduleExport => {
                // Although 'star' imports (e.g. `export * from 'some/module';) get resolved automatically by the compiler/binder,
                // it seems that explicit imports (e.g. `export {SomeClass} from 'some/module'`) do not so we have to do a little work.
                if (moduleExport.flags & typescript_1.SymbolFlags.Alias) {
                    // To maintain the alias information (particularly the alias name) we just attach the original "resolved" symbol to the alias symbol
                    moduleExport.resolvedSymbol = typeChecker.getAliasedSymbol(moduleExport);
                }
            });
        });
        moduleSymbols.typeChecker = typeChecker;
        return { host, moduleSymbols, program, typeChecker };
    }
}
exports.TsParser = TsParser;
//# sourceMappingURL=index.js.map