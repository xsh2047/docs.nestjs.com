"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertPrivateClassesToInterfaces = void 0;
const ConstExportDoc_1 = require("../api-doc-types/ConstExportDoc");
function convertPrivateClassesToInterfaces(exportDocs, addInjectableReference) {
    exportDocs.forEach(exportDoc => {
        // Search for classes with a constructor marked as `@internal`
        if (isPrivateClassExportDoc(exportDoc)) {
            // Convert this class to an interface with no constructor
            exportDoc.docType = 'interface';
            exportDoc.constructorDoc = undefined;
            // convert the heritage since interfaces use `extends` not `implements`
            exportDoc.extendsClauses = exportDoc.extendsClauses.concat(exportDoc.implementsClauses);
            if (addInjectableReference) {
                // Add the `declare var SomeClass extends InjectableReference` construct
                const constExportDoc = new ConstExportDoc_1.ConstExportDoc(exportDoc.host, exportDoc.moduleDoc, exportDoc.symbol, exportDoc.aliasSymbol);
                constExportDoc.type = 'InjectableReference';
                exportDocs.push(constExportDoc);
            }
        }
    });
}
exports.convertPrivateClassesToInterfaces = convertPrivateClassesToInterfaces;
/** Whether the specified document is a class document with an internal constructor. */
function isPrivateClassExportDoc(doc) {
    return doc.docType === 'class' && doc.constructorDoc && doc.constructorDoc.internal;
}
//# sourceMappingURL=convertPrivateClassesToInterfaces.js.map