"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkInheritedDocs = exports.linkInheritedDocs = void 0;
const ClassLikeExportDoc_1 = require("../api-doc-types/ClassLikeExportDoc");
function linkInheritedDocs(exportSymbolsToDocsMap, createDocMessage, log) {
    return new LinkInheritedDocs(exportSymbolsToDocsMap, createDocMessage, log);
}
exports.linkInheritedDocs = linkInheritedDocs;
class LinkInheritedDocs {
    constructor(exportSymbolsToDocsMap, createDocMessage, log) {
        this.exportSymbolsToDocsMap = exportSymbolsToDocsMap;
        this.createDocMessage = createDocMessage;
        this.log = log;
        this.$runAfter = ['readTypeScriptModules'];
        this.$runBefore = ['parsing-tags'];
    }
    $process(docs) {
        docs.forEach((doc) => {
            if (doc instanceof ClassLikeExportDoc_1.ClassLikeExportDoc) {
                this.log.debug(`- processing typecript doc ${doc.id} for ancestors`);
                doc.extendsClauses.forEach(clause => this.updateHeritageInfo(doc, clause));
                this.log.debug('  - found "extends" ancestors: ' + doc.extendsClauses.map(clause => clause.doc && clause.doc.id).join(', '));
                this.reportErrors(doc, doc.extendsClauses);
                doc.implementsClauses.forEach(clause => this.updateHeritageInfo(doc, clause));
                this.log.debug('  - found "implements" ancestors: ' + doc.implementsClauses.map(clause => clause.doc && clause.doc.id).join(', '));
                this.reportErrors(doc, doc.implementsClauses);
            }
        });
    }
    updateHeritageInfo(doc, clause) {
        clause.symbol = doc.typeChecker.getTypeFromTypeNode(clause.type).getSymbol();
        clause.doc = clause.symbol && this.exportSymbolsToDocsMap.get(clause.symbol);
        if (clause.doc)
            clause.doc.descendants.push(doc);
    }
    reportErrors(doc, clauses) {
        const missingSymbols = [];
        const missingDocs = [];
        clauses.forEach(clause => {
            if (!clause.doc) {
                (clause.symbol ? missingDocs : missingSymbols).push(clause.text);
            }
        });
        if (missingSymbols.length) {
            this.log.warn(this.createDocMessage(`Unresolved TypeScript symbol(s): ${missingSymbols.join(', ')}`, doc));
        }
        if (missingDocs.length) {
            this.createDocMessage(`Missing API doc for the following symbol(s): ${missingDocs.join(', ')}, (missing public export?)`, doc);
        }
    }
}
exports.LinkInheritedDocs = LinkInheritedDocs;
//# sourceMappingURL=linkInheritedDocs.js.map