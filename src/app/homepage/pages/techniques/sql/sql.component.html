
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/techniques/sql.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="database">Database</h3>
<p>Nest is database agnostic, allowing you to easily integrate with any SQL or NoSQL database. You have a number of options available to you, depending on your preferences. At the most general level, connecting Nest to a database is simply a matter of loading an appropriate Node.js driver for the database, just as you would with <a rel='nofollow' target='_blank' href="https://expressjs.com/en/guide/database-integration.html">Express</a> or Fastify.</p>
<p>You can also directly use any general purpose Node.js database integration <strong>library</strong> or ORM, such as <a rel='nofollow' target='_blank' href="https://mikro-orm.io/">MikroORM</a> (see <a routerLink="/recipes/mikroorm">MikroORM recipe</a>), <a rel='nofollow' target='_blank' href="https://sequelize.org/">Sequelize</a> (see <a href="/techniques/database#sequelize-integration">Sequelize integration</a>), <a rel='nofollow' target='_blank' href="https://knexjs.org/">Knex.js</a> (see <a rel='nofollow' target='_blank' href="https://dev.to/nestjs/build-a-nestjs-module-for-knex-js-or-other-resource-based-libraries-in-5-minutes-12an">Knex.js tutorial</a>), <a rel='nofollow' target='_blank' href="https://github.com/typeorm/typeorm">TypeORM</a>, and <a rel='nofollow' target='_blank' href="https://www.github.com/prisma/prisma">Prisma</a> (see <a routerLink="/recipes/prisma">Prisma recipe</a>), to operate at a higher level of abstraction.</p>
<p>For convenience, Nest provides tight integration with TypeORM and Sequelize out-of-the-box with the <code>@nestjs/typeorm</code> and <code>@nestjs/sequelize</code> packages respectively, which we&#39;ll cover in the current chapter, and Mongoose with <code>@nestjs/mongoose</code>, which is covered in <a routerLink="/techniques/mongodb">this chapter</a>. These integrations provide additional NestJS-specific features, such as model/repository injection, testability, and asynchronous configuration to make accessing your chosen database even easier.</p>
<h3 id="typeorm-integration">TypeORM Integration</h3>
<p>For integrating with SQL and NoSQL databases, Nest provides the <code>@nestjs/typeorm</code> package. <a rel='nofollow' target='_blank' href="https://github.com/typeorm/typeorm">TypeORM</a> is the most mature Object Relational Mapper (ORM) available for TypeScript. Since it&#39;s written in TypeScript, it integrates well with the Nest framework.</p>
<p>To begin using it, we first install the required dependencies. In this chapter, we&#39;ll demonstrate using the popular <a rel='nofollow' target='_blank' href="https://www.mysql.com/">MySQL</a> Relational DBMS, but TypeORM provides support for many relational databases, such as PostgreSQL, Oracle, Microsoft SQL Server, SQLite, and even NoSQL databases like MongoDB. The procedure we walk through in this chapter will be the same for any database supported by TypeORM. You&#39;ll simply need to install the associated client API libraries for your selected database.</p>
<pre><code class="language-bash">
$ npm install --save @nestjs/typeorm typeorm mysql2
</code></pre>
<p>Once the installation process is complete, we can import the <code>TypeOrmModule</code> into the root <code>AppModule</code>.</p>

<span class="filename">
  {{ 'app.module' | extension: app012b5cf1e3b0972c3304184335dd6071717f3b6b.isJsActive }}
<app-tabs #app012b5cf1e3b0972c3304184335dd6071717f3b6b></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; TypeOrmModule &#125; from &#39;@nestjs/typeorm&#39;;

@Module(&#123;
  imports: [
    TypeOrmModule.forRoot(&#123;
      type: &#39;mysql&#39;,
      host: &#39;localhost&#39;,
      port: 3306,
      username: &#39;root&#39;,
      password: &#39;root&#39;,
      database: &#39;test&#39;,
      entities: [],
      synchronize: true,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre><blockquote class="
warning "><strong>Warning</strong> Setting <code>synchronize: true</code> shouldn&#39;t be used in production - otherwise you can lose production data.
</blockquote>
<p>The <code>forRoot()</code> method supports all the configuration properties exposed by the <code>DataSource</code> constructor from the <a rel='nofollow' target='_blank' href="https://typeorm.io/data-source-options#common-data-source-options">TypeORM</a> package. In addition, there are several extra configuration properties described below.</p>
<table>
  <tr>
    <td><code>retryAttempts</code></td>
    <td>Number of attempts to connect to the database (default: <code>10</code>)</td>
  </tr>
  <tr>
    <td><code>retryDelay</code></td>
    <td>Delay between connection retry attempts (ms) (default: <code>3000</code>)</td>
  </tr>
  <tr>
    <td><code>autoLoadEntities</code></td>
    <td>If <code>true</code>, entities will be loaded automatically (default: <code>false</code>)</td>
  </tr>
</table>

<blockquote class="
info "><strong>Hint</strong> Learn more about the data source options <a rel='nofollow' target='_blank' href="https://typeorm.io/data-source-options">here</a>.
</blockquote>
<p>Once this is done, the TypeORM <code>DataSource</code> and <code>EntityManager</code> objects will be available to inject across the entire project (without needing to import any modules), for example:</p>

<span class="filename">
  {{ 'app.module' | extension: app749ef294849239345ca119a403b59e868f62648e.isJsActive }}
<app-tabs #app749ef294849239345ca119a403b59e868f62648e></app-tabs>
</span><pre [class.hide]="app749ef294849239345ca119a403b59e868f62648e.isJsActive"><code class="language-typescript">
import &#123; DataSource &#125; from &#39;typeorm&#39;;

@Module(&#123;
  imports: [TypeOrmModule.forRoot(), UsersModule],
&#125;)
export class AppModule &#123;
  constructor(private dataSource: DataSource) &#123;&#125;
&#125;
</code></pre>
<pre [class.hide]="!app749ef294849239345ca119a403b59e868f62648e.isJsActive"><code class="language-typescript">
import &#123; DataSource &#125; from &#39;typeorm&#39;;

@Dependencies(DataSource)
@Module(&#123;
  imports: [TypeOrmModule.forRoot(), UsersModule],
&#125;)
export class AppModule &#123;
  constructor(dataSource) &#123;
    this.dataSource = dataSource;
  &#125;
&#125;
</code></pre><h4 appAnchor id="repository-pattern"><span>Repository pattern</span></h4>
<p><a rel='nofollow' target='_blank' href="https://github.com/typeorm/typeorm">TypeORM</a> supports the <strong>repository design pattern</strong>, so each entity has its own repository. These repositories can be obtained from the database data source.</p>
<p>To continue the example, we need at least one entity. Let&#39;s define the <code>User</code> entity.</p>

<span class="filename">
  {{ 'user.entity' | extension: app3afd9a84accd6941e20e75dbb6b596419455f404.isJsActive }}
<app-tabs #app3afd9a84accd6941e20e75dbb6b596419455f404></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Entity, Column, PrimaryGeneratedColumn &#125; from &#39;typeorm&#39;;

@Entity()
export class User &#123;
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column(&#123; default: true &#125;)
  isActive: boolean;
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> Learn more about entitiesÂ in the <a rel='nofollow' target='_blank' href="https://typeorm.io/#/entities">TypeORM documentation</a>.
</blockquote>
<p>The <code>User</code> entity file sits in the <code>users</code> directory. This directory contains all files related to the <code>UsersModule</code>. You can decide where to keep your model files, however, we recommend creating them near their <strong>domain</strong>, in the corresponding module directory.</p>
<p>To begin using the <code>User</code> entity, we need to let TypeORM know about it by inserting it into the <code>entities</code> array in the module <code>forRoot()</code> method options (unless you use a static glob path):</p>

<span class="filename">
  {{ 'app.module' | extension: appb50898da58f3c6ee1ba73fd9f3aa140fc11db3b6.isJsActive }}
<app-tabs #appb50898da58f3c6ee1ba73fd9f3aa140fc11db3b6></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; TypeOrmModule &#125; from &#39;@nestjs/typeorm&#39;;
import &#123; User &#125; from &#39;./users/user.entity&#39;;

@Module(&#123;
  imports: [
    TypeOrmModule.forRoot(&#123;
      type: &#39;mysql&#39;,
      host: &#39;localhost&#39;,
      port: 3306,
      username: &#39;root&#39;,
      password: &#39;root&#39;,
      database: &#39;test&#39;,
      entities: [User],
      synchronize: true,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre><p>Next, let&#39;s look at the <code>UsersModule</code>:</p>

<span class="filename">
  {{ 'users.module' | extension: app52f83f39eb59f46eb1f700c120a17b0c885b9a00.isJsActive }}
<app-tabs #app52f83f39eb59f46eb1f700c120a17b0c885b9a00></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; TypeOrmModule &#125; from &#39;@nestjs/typeorm&#39;;
import &#123; UsersService &#125; from &#39;./users.service&#39;;
import &#123; UsersController &#125; from &#39;./users.controller&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;

@Module(&#123;
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
&#125;)
export class UsersModule &#123;&#125;
</code></pre><p>This module uses the <code>forFeature()</code> method to define which repositories are registered in the current scope. With that in place, we can inject the <code>UsersRepository</code> into the <code>UsersService</code> using the <code>@InjectRepository()</code> decorator:</p>

<span class="filename">
  {{ 'users.service' | extension: appa9c4a8bd12e4829cc5e2411504860a459e18068e.isJsActive }}
<app-tabs #appa9c4a8bd12e4829cc5e2411504860a459e18068e></app-tabs>
</span><pre [class.hide]="appa9c4a8bd12e4829cc5e2411504860a459e18068e.isJsActive"><code class="language-typescript">
import &#123; Injectable &#125; from &#39;@nestjs/common&#39;;
import &#123; InjectRepository &#125; from &#39;@nestjs/typeorm&#39;;
import &#123; Repository &#125; from &#39;typeorm&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;

@Injectable()
export class UsersService &#123;
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository&lt;User&gt;,
  ) &#123;&#125;

  findAll(): Promise&lt;User[]&gt; &#123;
    return this.usersRepository.find();
  &#125;

  findOne(id: number): Promise&lt;User | null&gt; &#123;
    return this.usersRepository.findOneBy(&#123; id &#125;);
  &#125;

  async remove(id: number): Promise&lt;void&gt; &#123;
    await this.usersRepository.delete(id);
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!appa9c4a8bd12e4829cc5e2411504860a459e18068e.isJsActive"><code class="language-typescript">
import &#123; Injectable, Dependencies &#125; from &#39;@nestjs/common&#39;;
import &#123; getRepositoryToken &#125; from &#39;@nestjs/typeorm&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;

@Injectable()
@Dependencies(getRepositoryToken(User))
export class UsersService &#123;
  constructor(usersRepository) &#123;
    this.usersRepository = usersRepository;
  &#125;

  findAll() &#123;
    return this.usersRepository.find();
  &#125;

  findOne(id) &#123;
    return this.usersRepository.findOneBy(&#123; id &#125;);
  &#125;

  async remove(id) &#123;
    await this.usersRepository.delete(id);
  &#125;
&#125;
</code></pre><blockquote class="
warning "><strong>Notice</strong> Don&#39;t forget to import the <code>UsersModule</code> into the root <code>AppModule</code>.
</blockquote>
<p>If you want to use the repository outside of the module which imports <code>TypeOrmModule.forFeature</code>, you&#39;ll need to re-export the providers generated by it.
You can do this by exporting the whole module, like this:</p>

<span class="filename">
  {{ 'users.module' | extension: app4b44f349474f435db0b9cf05a9d191dce8c704d9.isJsActive }}
<app-tabs #app4b44f349474f435db0b9cf05a9d191dce8c704d9></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; TypeOrmModule &#125; from &#39;@nestjs/typeorm&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;

@Module(&#123;
  imports: [TypeOrmModule.forFeature([User])],
  exports: [TypeOrmModule]
&#125;)
export class UsersModule &#123;&#125;
</code></pre><p>Now if we import <code>UsersModule</code> in <code>UserHttpModule</code>, we can use <code>@InjectRepository(User)</code> in the providers of the latter module.</p>

<span class="filename">
  {{ 'users-http.module' | extension: app239b5b5c7c870e731d27d91bcc91e9f3fb0cc454.isJsActive }}
<app-tabs #app239b5b5c7c870e731d27d91bcc91e9f3fb0cc454></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; UsersModule &#125; from &#39;./users.module&#39;;
import &#123; UsersService &#125; from &#39;./users.service&#39;;
import &#123; UsersController &#125; from &#39;./users.controller&#39;;

@Module(&#123;
  imports: [UsersModule],
  providers: [UsersService],
  controllers: [UsersController]
&#125;)
export class UserHttpModule &#123;&#125;
</code></pre><h4 appAnchor id="relations"><span>Relations</span></h4>
<p>Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.</p>
<p>There are three types of relations:</p>
<table>
  <tr>
    <td><code>One-to-one</code></td>
    <td>Every row in the primary table has one and only one associated row in the foreign table.  Use the <code>@OneToOne()</code> decorator to define this type of relation.</td>
  </tr>
  <tr>
    <td><code>One-to-many / Many-to-one</code></td>
    <td>Every row in the primary table has one or more related rows in the foreign table. Use the <code>@OneToMany()</code> and <code>@ManyToOne()</code> decorators to define this type of relation.</td>
  </tr>
  <tr>
    <td><code>Many-to-many</code></td>
    <td>Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table. Use the <code>@ManyToMany()</code> decorator to define this type of relation.</td>
  </tr>
</table>

<p>To define relations in entities, use the corresponding <strong>decorators</strong>. For example, to define that each <code>User</code> can have multiple photos, use the <code>@OneToMany()</code> decorator.</p>

<span class="filename">
  {{ 'user.entity' | extension: app67e3be32e3b0b9c9ee17e6d672e6501200b65d2d.isJsActive }}
<app-tabs #app67e3be32e3b0b9c9ee17e6d672e6501200b65d2d></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Entity, Column, PrimaryGeneratedColumn, OneToMany &#125; from &#39;typeorm&#39;;
import &#123; Photo &#125; from &#39;../photos/photo.entity&#39;;

@Entity()
export class User &#123;
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column(&#123; default: true &#125;)
  isActive: boolean;

  @OneToMany(type =&gt; Photo, photo =&gt; photo.user)
  photos: Photo[];
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> To learn more about relations in TypeORM, visit the <a rel='nofollow' target='_blank' href="https://typeorm.io/#/relations">TypeORM documentation</a>.
</blockquote>
<h4 appAnchor id="auto-load-entities"><span>Auto-load entities</span></h4>
<p>Manually adding entities to the <code>entities</code> array of the data source options can be tedious. In addition, referencing entities from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To address this issue, an alternative solution is provided. To automatically load entities, set the <code>autoLoadEntities</code> property of the configuration object (passed into the <code>forRoot()</code> method) to <code>true</code>, as shown below:</p>

<span class="filename">
  {{ 'app.module' | extension: app1305b0b90362139fb5bd1eb738d878c08b3c92c0.isJsActive }}
<app-tabs #app1305b0b90362139fb5bd1eb738d878c08b3c92c0></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; TypeOrmModule &#125; from &#39;@nestjs/typeorm&#39;;

@Module(&#123;
  imports: [
    TypeOrmModule.forRoot(&#123;
      ...
      autoLoadEntities: true,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre><p>With that option specified, every entity registered through the <code>forFeature()</code> method will be automatically added to the <code>entities</code> array of the configuration object.</p>
<blockquote class="
warning "><strong>Warning</strong> Note that entities that aren&#39;t registered through the <code>forFeature()</code> method, but are only referenced from the entity (via a relationship), won&#39;t be included by way of the <code>autoLoadEntities</code> setting.
</blockquote>
<h4 appAnchor id="separating-entity-definition"><span>Separating entity definition</span></h4>
<p>You can define an entity and its columns right in the model, using decorators. But some people prefer to define entities and their columns inside separate files using the <a rel='nofollow' target='_blank' href="https://typeorm.io/#/separating-entity-definition">&quot;entity schemas&quot;</a>.</p>
<pre><code class="language-typescript">
import &#123; EntitySchema &#125; from &#39;typeorm&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;

export const UserSchema = new EntitySchema&lt;User&gt;(&#123;
  name: &#39;User&#39;,
  target: User,
  columns: &#123;
    id: &#123;
      type: Number,
      primary: true,
      generated: true,
    &#125;,
    firstName: &#123;
      type: String,
    &#125;,
    lastName: &#123;
      type: String,
    &#125;,
    isActive: &#123;
      type: Boolean,
      default: true,
    &#125;,
  &#125;,
  relations: &#123;
    photos: &#123;
      type: &#39;one-to-many&#39;,
      target: &#39;Photo&#39;, // the name of the PhotoSchema
    &#125;,
  &#125;,
&#125;);
</code></pre>
<blockquote class="
warning error "><strong>Warning</strong> If you provide the <code>target</code> option, the <code>name</code> option value has to be the same as the name of the target class.
If you do not provide the <code>target</code> you can use any name.
</blockquote>
<p>Nest allows you to use an <code>EntitySchema</code> instance wherever an <code>Entity</code> is expected, for example:</p>
<pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; TypeOrmModule &#125; from &#39;@nestjs/typeorm&#39;;
import &#123; UserSchema &#125; from &#39;./user.schema&#39;;
import &#123; UsersController &#125; from &#39;./users.controller&#39;;
import &#123; UsersService &#125; from &#39;./users.service&#39;;

@Module(&#123;
  imports: [TypeOrmModule.forFeature([UserSchema])],
  providers: [UsersService],
  controllers: [UsersController],
&#125;)
export class UsersModule &#123;&#125;
</code></pre>
<h4 appAnchor id="typeorm-transactions"><span>TypeORM Transactions</span></h4>
<p>A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database (<a rel='nofollow' target='_blank' href="https://en.wikipedia.org/wiki/Database_transaction">learn more</a>).</p>
<p>There are many different strategies to handle <a rel='nofollow' target='_blank' href="https://typeorm.io/#/transactions">TypeORM transactions</a>. We recommend using the <code>QueryRunner</code> class because it gives full control over the transaction.</p>
<p>First, we need to inject the <code>DataSource</code> object into a class in the normal way:</p>
<pre><code class="language-typescript">
@Injectable()
export class UsersService &#123;
  constructor(private dataSource: DataSource) &#123;&#125;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> The <code>DataSource</code> class is imported from the <code>typeorm</code> package.
</blockquote>
<p>Now, we can use this object to create a transaction.</p>
<pre><code class="language-typescript">
async createMany(users: User[]) &#123;
  const queryRunner = this.dataSource.createQueryRunner();

  await queryRunner.connect();
  await queryRunner.startTransaction();
  try &#123;
    await queryRunner.manager.save(users[0]);
    await queryRunner.manager.save(users[1]);

    await queryRunner.commitTransaction();
  &#125; catch (err) &#123;
    // since we have errors lets rollback the changes we made
    await queryRunner.rollbackTransaction();
  &#125; finally &#123;
    // you need to release a queryRunner which was manually instantiated
    await queryRunner.release();
  &#125;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Note that the <code>dataSource</code> is used only to create the <code>QueryRunner</code>. However, to test this class would require mocking the entire <code>DataSource</code> object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., <code>QueryRunnerFactory</code>) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.
</blockquote>
<p><app-banner-devtools></app-banner-devtools></p>
<p>Alternatively, you can use the callback-style approach with the <code>transaction</code> method of the <code>DataSource</code> object (<a rel='nofollow' target='_blank' href="https://typeorm.io/#/transactions/creating-and-using-transactions">read more</a>).</p>
<pre><code class="language-typescript">
async createMany(users: User[]) &#123;
  await this.dataSource.transaction(async manager =&gt; &#123;
    await manager.save(users[0]);
    await manager.save(users[1]);
  &#125;);
&#125;
</code></pre>
<h4 appAnchor id="subscribers"><span>Subscribers</span></h4>
<p>With TypeORM <a rel='nofollow' target='_blank' href="https://typeorm.io/#/listeners-and-subscribers/what-is-a-subscriber">subscribers</a>, you can listen to specific entity events.</p>
<pre><code class="language-typescript">
import &#123;
  DataSource,
  EntitySubscriberInterface,
  EventSubscriber,
  InsertEvent,
&#125; from &#39;typeorm&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;

@EventSubscriber()
export class UserSubscriber implements EntitySubscriberInterface&lt;User&gt; &#123;
  constructor(dataSource: DataSource) &#123;
    dataSource.subscribers.push(this);
  &#125;

  listenTo() &#123;
    return User;
  &#125;

  beforeInsert(event: InsertEvent&lt;User&gt;) &#123;
    console.log(`BEFORE USER INSERTED: `, event.entity);
  &#125;
&#125;
</code></pre>
<blockquote class="
error "><strong>Warning</strong> Event subscribers can not be <a routerLink="/fundamentals/injection-scopes">request-scoped</a>.
</blockquote>
<p>Now, add the <code>UserSubscriber</code> class to the <code>providers</code> array:</p>
<pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; TypeOrmModule &#125; from &#39;@nestjs/typeorm&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;
import &#123; UsersController &#125; from &#39;./users.controller&#39;;
import &#123; UsersService &#125; from &#39;./users.service&#39;;
import &#123; UserSubscriber &#125; from &#39;./user.subscriber&#39;;

@Module(&#123;
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService, UserSubscriber],
  controllers: [UsersController],
&#125;)
export class UsersModule &#123;&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Learn more about entity subscribers <a rel='nofollow' target='_blank' href="https://typeorm.io/#/listeners-and-subscribers/what-is-a-subscriber">here</a>.
</blockquote>
<h4 appAnchor id="migrations"><span>Migrations</span></h4>
<p><a rel='nofollow' target='_blank' href="https://typeorm.io/#/migrations">Migrations</a> provide a way to incrementally update the database schema to keep it in sync with the application&#39;s data model while preserving existing data in the database. To generate, run, and revert migrations, TypeORM provides a dedicated <a rel='nofollow' target='_blank' href="https://typeorm.io/#/migrations/creating-a-new-migration">CLI</a>.</p>
<p>Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the TypeORM CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the <a rel='nofollow' target='_blank' href="https://typeorm.io/#/migrations/creating-a-new-migration">TypeORM documentation</a>.</p>
<h4 appAnchor id="multiple-databases"><span>Multiple databases</span></h4>
<p>Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, data source naming becomes <strong>mandatory</strong>.</p>
<p>Suppose you have an <code>Album</code> entity stored in its own database.</p>
<pre><code class="language-typescript">
const defaultOptions = &#123;
  type: &#39;postgres&#39;,
  port: 5432,
  username: &#39;user&#39;,
  password: &#39;password&#39;,
  database: &#39;db&#39;,
  synchronize: true,
&#125;;

@Module(&#123;
  imports: [
    TypeOrmModule.forRoot(&#123;
      ...defaultOptions,
      host: &#39;user_db_host&#39;,
      entities: [User],
    &#125;),
    TypeOrmModule.forRoot(&#123;
      ...defaultOptions,
      name: &#39;albumsConnection&#39;,
      host: &#39;album_db_host&#39;,
      entities: [Album],
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<blockquote class="
warning "><strong>Notice</strong> If you don&#39;t set the <code>name</code> for a data source, its name is set to <code>default</code>. Please note that you shouldn&#39;t have multiple connections without a name, or with the same name, otherwise they will get overridden.
</blockquote>
<blockquote class="
warning "><strong>Notice</strong> If you are using <code>TypeOrmModule.forRootAsync</code>, you have to <strong>also</strong> set the data source name outside <code>useFactory</code>. For example:
<pre><code class="language-typescript">
TypeOrmModule.forRootAsync(&#123;
  name: &#39;albumsConnection&#39;,
  useFactory: ...,
  inject: ...,
&#125;),
</code></pre>
<p>See <a rel='nofollow' target='_blank' href="https://github.com/nestjs/typeorm/issues/86">this issue</a> for more details.</p>
</blockquote>
<p>At this point, you have <code>User</code> and <code>Album</code> entities registered with their own data source. With this setup, you have to tell the <code>TypeOrmModule.forFeature()</code> method and the <code>@InjectRepository()</code> decorator which data source should be used. If you do not pass any data source name, the <code>default</code> data source is used.</p>
<pre><code class="language-typescript">
@Module(&#123;
  imports: [
    TypeOrmModule.forFeature([User]),
    TypeOrmModule.forFeature([Album], &#39;albumsConnection&#39;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>You can also inject the <code>DataSource</code> or <code>EntityManager</code> for a given data source:</p>
<pre><code class="language-typescript">
@Injectable()
export class AlbumsService &#123;
  constructor(
    @InjectDataSource(&#39;albumsConnection&#39;)
    private dataSource: DataSource,
    @InjectEntityManager(&#39;albumsConnection&#39;)
    private entityManager: EntityManager,
  ) &#123;&#125;
&#125;
</code></pre>
<p>It&#39;s also possible to inject any <code>DataSource</code> to the providers:</p>
<pre><code class="language-typescript">
@Module(&#123;
  providers: [
    &#123;
      provide: AlbumsService,
      useFactory: (albumsConnection: DataSource) =&gt; &#123;
        return new AlbumsService(albumsConnection);
      &#125;,
      inject: [getDataSourceToken(&#39;albumsConnection&#39;)],
    &#125;,
  ],
&#125;)
export class AlbumsModule &#123;&#125;
</code></pre>
<h4 appAnchor id="testing"><span>Testing</span></h4>
<p>When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on repositories that are pulled from the data source (connection) instance. How do we handle that? The solution is to create mock repositories. In order to achieve that, we set up <a routerLink="/fundamentals/custom-providers">custom providers</a>. Each registered repository is automatically represented by an <code>&lt;EntityName&gt;Repository</code> token, where <code>EntityName</code> is the name of your entity class.</p>
<p>The <code>@nestjs/typeorm</code> package exposes the <code>getRepositoryToken()</code> function which returns a prepared token based on a given entity.</p>
<pre><code class="language-typescript">
@Module(&#123;
  providers: [
    UsersService,
    &#123;
      provide: getRepositoryToken(User),
      useValue: mockRepository,
    &#125;,
  ],
&#125;)
export class UsersModule &#123;&#125;
</code></pre>
<p>Now a substitute <code>mockRepository</code> will be used as the <code>UsersRepository</code>. Whenever any class asks for <code>UsersRepository</code> using an <code>@InjectRepository()</code> decorator, Nest will use the registered <code>mockRepository</code> object.</p>
<h4 appAnchor id="async-configuration"><span>Async configuration</span></h4>
<p>You may want to pass your repository module options asynchronously instead of statically. In this case, use the <code>forRootAsync()</code> method, which provides several ways to deal with async configuration.</p>
<p>One approach is to use a factory function:</p>
<pre><code class="language-typescript">
TypeOrmModule.forRootAsync(&#123;
  useFactory: () =&gt; (&#123;
    type: &#39;mysql&#39;,
    host: &#39;localhost&#39;,
    port: 3306,
    username: &#39;root&#39;,
    password: &#39;root&#39;,
    database: &#39;test&#39;,
    entities: [],
    synchronize: true,
  &#125;),
&#125;);
</code></pre>
<p>Our factory behaves like any other <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/fundamentals/async-providers">asynchronous provider</a> (e.g., it can be <code>async</code> and it&#39;s able to inject dependencies through <code>inject</code>).</p>
<pre><code class="language-typescript">
TypeOrmModule.forRootAsync(&#123;
  imports: [ConfigModule],
  useFactory: (configService: ConfigService) =&gt; (&#123;
    type: &#39;mysql&#39;,
    host: configService.get(&#39;HOST&#39;),
    port: +configService.get(&#39;PORT&#39;),
    username: configService.get(&#39;USERNAME&#39;),
    password: configService.get(&#39;PASSWORD&#39;),
    database: configService.get(&#39;DATABASE&#39;),
    entities: [],
    synchronize: true,
  &#125;),
  inject: [ConfigService],
&#125;);
</code></pre>
<p>Alternatively, you can use the <code>useClass</code> syntax:</p>
<pre><code class="language-typescript">
TypeOrmModule.forRootAsync(&#123;
  useClass: TypeOrmConfigService,
&#125;);
</code></pre>
<p>The construction above will instantiate <code>TypeOrmConfigService</code> inside <code>TypeOrmModule</code> and use it to provide an options object by calling <code>createTypeOrmOptions()</code>. Note that this means that the <code>TypeOrmConfigService</code> has to implement the <code>TypeOrmOptionsFactory</code> interface, as shown below:</p>
<pre><code class="language-typescript">
@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory &#123;
  createTypeOrmOptions(): TypeOrmModuleOptions &#123;
    return &#123;
      type: &#39;mysql&#39;,
      host: &#39;localhost&#39;,
      port: 3306,
      username: &#39;root&#39;,
      password: &#39;root&#39;,
      database: &#39;test&#39;,
      entities: [],
      synchronize: true,
    &#125;;
  &#125;
&#125;
</code></pre>
<p>In order to prevent the creation of <code>TypeOrmConfigService</code> inside <code>TypeOrmModule</code> and use a provider imported from a different module, you can use the <code>useExisting</code> syntax.</p>
<pre><code class="language-typescript">
TypeOrmModule.forRootAsync(&#123;
  imports: [ConfigModule],
  useExisting: ConfigService,
&#125;);
</code></pre>
<p>This construction works the same as <code>useClass</code> with one critical difference - <code>TypeOrmModule</code> will lookup imported modules to reuse an existing <code>ConfigService</code> instead of instantiating a new one.</p>
<blockquote class="
info "><strong>Hint</strong> Make sure that the <code>name</code> property is defined at the same level as the <code>useFactory</code>, <code>useClass</code>, or <code>useValue</code> property. This will allow Nest to properly register the data source under the appropriate injection token.
</blockquote>
<h4 appAnchor id="custom-datasource-factory"><span>Custom DataSource Factory</span></h4>
<p>In conjunction with async configuration using <code>useFactory</code>, <code>useClass</code>, or <code>useExisting</code>, you can optionally specify a <code>dataSourceFactory</code> function which will allow you to provide your own TypeORM data source rather than allowing <code>TypeOrmModule</code> to create the data source.</p>
<p><code>dataSourceFactory</code> receives the TypeORM <code>DataSourceOptions</code> configured during async configuration using <code>useFactory</code>, <code>useClass</code>, or <code>useExisting</code> and returns a <code>Promise</code> that resolves a TypeORM <code>DataSource</code>.</p>
<pre><code class="language-typescript">
TypeOrmModule.forRootAsync(&#123;
  imports: [ConfigModule],
  inject: [ConfigService],
  // Use useFactory, useClass, or useExisting
  // to configure the DataSourceOptions.
  useFactory: (configService: ConfigService) =&gt; (&#123;
    type: &#39;mysql&#39;,
    host: configService.get(&#39;HOST&#39;),
    port: +configService.get(&#39;PORT&#39;),
    username: configService.get(&#39;USERNAME&#39;),
    password: configService.get(&#39;PASSWORD&#39;),
    database: configService.get(&#39;DATABASE&#39;),
    entities: [],
    synchronize: true,
  &#125;),
  // dataSource receives the configured DataSourceOptions
  // and returns a Promise&lt;DataSource&gt;.
  dataSourceFactory: async (options) =&gt; &#123;
    const dataSource = await new DataSource(options).initialize();
    return dataSource;
  &#125;,
&#125;);
</code></pre>
<blockquote class="
info "><strong>Hint</strong> The <code>DataSource</code> class is imported from the <code>typeorm</code> package.
</blockquote>
<h4 appAnchor id="example"><span>Example</span></h4>
<p>A working example is available <a rel='nofollow' target='_blank' href="https://github.com/nestjs/nest/tree/master/sample/05-sql-typeorm">here</a>.</p>
<p><app-banner-enterprise></app-banner-enterprise></p>
<h3 id="sequelize-integration">Sequelize Integration</h3>
<p>An alternative to using TypeORM is to use the <a rel='nofollow' target='_blank' href="https://sequelize.org/">Sequelize</a> ORM with the <code>@nestjs/sequelize</code> package. In addition, we leverage the <a rel='nofollow' target='_blank' href="https://github.com/RobinBuschmann/sequelize-typescript">sequelize-typescript</a> package which provides a set of additional decorators to declaratively define entities.</p>
<p>To begin using it, we first install the required dependencies. In this chapter, we&#39;ll demonstrate using the popular <a rel='nofollow' target='_blank' href="https://www.mysql.com/">MySQL</a> Relational DBMS, but Sequelize provides support for many relational databases, such as PostgreSQL, MySQL, Microsoft SQL Server, SQLite, and MariaDB. The procedure we walk through in this chapter will be the same for any database supported by Sequelize. You&#39;ll simply need to install the associated client API libraries for your selected database.</p>
<pre><code class="language-bash">
$ npm install --save @nestjs/sequelize sequelize sequelize-typescript mysql2
$ npm install --save-dev @types/sequelize
</code></pre>
<p>Once the installation process is complete, we can import the <code>SequelizeModule</code> into the root <code>AppModule</code>.</p>

<span class="filename">
  {{ 'app.module' | extension: appa2c13d78d7737c9ebc80ef56f37e0d9e79b7377f.isJsActive }}
<app-tabs #appa2c13d78d7737c9ebc80ef56f37e0d9e79b7377f></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; SequelizeModule &#125; from &#39;@nestjs/sequelize&#39;;

@Module(&#123;
  imports: [
    SequelizeModule.forRoot(&#123;
      dialect: &#39;mysql&#39;,
      host: &#39;localhost&#39;,
      port: 3306,
      username: &#39;root&#39;,
      password: &#39;root&#39;,
      database: &#39;test&#39;,
      models: [],
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre><p>The <code>forRoot()</code> method supports all the configuration properties exposed by the Sequelize constructor (<a rel='nofollow' target='_blank' href="https://sequelize.org/v5/manual/getting-started.html#setting-up-a-connection">read more</a>). In addition, there are several extra configuration properties described below.</p>
<table>
  <tr>
    <td><code>retryAttempts</code></td>
    <td>Number of attempts to connect to the database (default: <code>10</code>)</td>
  </tr>
  <tr>
    <td><code>retryDelay</code></td>
    <td>Delay between connection retry attempts (ms) (default: <code>3000</code>)</td>
  </tr>
  <tr>
    <td><code>autoLoadModels</code></td>
    <td>If <code>true</code>, models will be loaded automatically (default: <code>false</code>)</td>
  </tr>
  <tr>
    <td><code>keepConnectionAlive</code></td>
    <td>If <code>true</code>, connection will not be closed on the application shutdown (default: <code>false</code>)</td>
  </tr>
  <tr>
    <td><code>synchronize</code></td>
    <td>If <code>true</code>, automatically loaded models will be synchronized (default: <code>true</code>)</td>
  </tr>
</table>

<p>Once this is done, the <code>Sequelize</code> object will be available to inject across the entire project (without needing to import any modules), for example:</p>

<span class="filename">
  {{ 'app.service' | extension: app36a52ec0bf74447203150c61a481ea4463d20204.isJsActive }}
<app-tabs #app36a52ec0bf74447203150c61a481ea4463d20204></app-tabs>
</span><pre [class.hide]="app36a52ec0bf74447203150c61a481ea4463d20204.isJsActive"><code class="language-typescript">
import &#123; Injectable &#125; from &#39;@nestjs/common&#39;;
import &#123; Sequelize &#125; from &#39;sequelize-typescript&#39;;

@Injectable()
export class AppService &#123;
  constructor(private sequelize: Sequelize) &#123;&#125;
&#125;
</code></pre>
<pre [class.hide]="!app36a52ec0bf74447203150c61a481ea4463d20204.isJsActive"><code class="language-typescript">
import &#123; Injectable &#125; from &#39;@nestjs/common&#39;;
import &#123; Sequelize &#125; from &#39;sequelize-typescript&#39;;

@Dependencies(Sequelize)
@Injectable()
export class AppService &#123;
  constructor(sequelize) &#123;
    this.sequelize = sequelize;
  &#125;
&#125;
</code></pre><h4 appAnchor id="models"><span>Models</span></h4>
<p>Sequelize implements the Active Record pattern. With this pattern, you use model classes directly to interact with the database. To continue the example, we need at least one model. Let&#39;s define the <code>User</code> model.</p>

<span class="filename">
  {{ 'user.model' | extension: app712e3c03f93c8c7865a9b782a9b1962aecfb7389.isJsActive }}
<app-tabs #app712e3c03f93c8c7865a9b782a9b1962aecfb7389></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Column, Model, Table &#125; from &#39;sequelize-typescript&#39;;

@Table
export class User extends Model &#123;
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column(&#123; defaultValue: true &#125;)
  isActive: boolean;
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> Learn more about the available decorators <a rel='nofollow' target='_blank' href="https://github.com/RobinBuschmann/sequelize-typescript#column">here</a>.
</blockquote>
<p>The <code>User</code> model file sits in the <code>users</code> directory. This directory contains all files related to the <code>UsersModule</code>. You can decide where to keep your model files, however, we recommend creating them near their <strong>domain</strong>, in the corresponding module directory.</p>
<p>To begin using the <code>User</code> model, we need to let Sequelize know about it by inserting it into the <code>models</code> array in the module <code>forRoot()</code> method options:</p>

<span class="filename">
  {{ 'app.module' | extension: app50f1b2caf6fcbd35b13dd584efe9e9884907202c.isJsActive }}
<app-tabs #app50f1b2caf6fcbd35b13dd584efe9e9884907202c></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; SequelizeModule &#125; from &#39;@nestjs/sequelize&#39;;
import &#123; User &#125; from &#39;./users/user.model&#39;;

@Module(&#123;
  imports: [
    SequelizeModule.forRoot(&#123;
      dialect: &#39;mysql&#39;,
      host: &#39;localhost&#39;,
      port: 3306,
      username: &#39;root&#39;,
      password: &#39;root&#39;,
      database: &#39;test&#39;,
      models: [User],
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre><p>Next, let&#39;s look at the <code>UsersModule</code>:</p>

<span class="filename">
  {{ 'users.module' | extension: appe1112e80c8e61fe60bdc8dae63c40e94a22d0176.isJsActive }}
<app-tabs #appe1112e80c8e61fe60bdc8dae63c40e94a22d0176></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; SequelizeModule &#125; from &#39;@nestjs/sequelize&#39;;
import &#123; User &#125; from &#39;./user.model&#39;;
import &#123; UsersController &#125; from &#39;./users.controller&#39;;
import &#123; UsersService &#125; from &#39;./users.service&#39;;

@Module(&#123;
  imports: [SequelizeModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
&#125;)
export class UsersModule &#123;&#125;
</code></pre><p>This module uses the <code>forFeature()</code> method to define which models are registered in the current scope. With that in place, we can inject the <code>UserModel</code> into the <code>UsersService</code> using the <code>@InjectModel()</code> decorator:</p>

<span class="filename">
  {{ 'users.service' | extension: appdc3e95b4dec1439626ec697165057110ffb6e251.isJsActive }}
<app-tabs #appdc3e95b4dec1439626ec697165057110ffb6e251></app-tabs>
</span><pre [class.hide]="appdc3e95b4dec1439626ec697165057110ffb6e251.isJsActive"><code class="language-typescript">
import &#123; Injectable &#125; from &#39;@nestjs/common&#39;;
import &#123; InjectModel &#125; from &#39;@nestjs/sequelize&#39;;
import &#123; User &#125; from &#39;./user.model&#39;;

@Injectable()
export class UsersService &#123;
  constructor(
    @InjectModel(User)
    private userModel: typeof User,
  ) &#123;&#125;

  async findAll(): Promise&lt;User[]&gt; &#123;
    return this.userModel.findAll();
  &#125;

  findOne(id: string): Promise&lt;User&gt; &#123;
    return this.userModel.findOne(&#123;
      where: &#123;
        id,
      &#125;,
    &#125;);
  &#125;

  async remove(id: string): Promise&lt;void&gt; &#123;
    const user = await this.findOne(id);
    await user.destroy();
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!appdc3e95b4dec1439626ec697165057110ffb6e251.isJsActive"><code class="language-typescript">
import &#123; Injectable, Dependencies &#125; from &#39;@nestjs/common&#39;;
import &#123; getModelToken &#125; from &#39;@nestjs/sequelize&#39;;
import &#123; User &#125; from &#39;./user.model&#39;;

@Injectable()
@Dependencies(getModelToken(User))
export class UsersService &#123;
  constructor(usersRepository) &#123;
    this.usersRepository = usersRepository;
  &#125;

  async findAll() &#123;
    return this.userModel.findAll();
  &#125;

  findOne(id) &#123;
    return this.userModel.findOne(&#123;
      where: &#123;
        id,
      &#125;,
    &#125;);
  &#125;

  async remove(id) &#123;
    const user = await this.findOne(id);
    await user.destroy();
  &#125;
&#125;
</code></pre><blockquote class="
warning "><strong>Notice</strong> Don&#39;t forget to import the <code>UsersModule</code> into the root <code>AppModule</code>.
</blockquote>
<p>If you want to use the repository outside of the module which imports <code>SequelizeModule.forFeature</code>, you&#39;ll need to re-export the providers generated by it.
You can do this by exporting the whole module, like this:</p>

<span class="filename">
  {{ 'users.module' | extension: app68e62aaa46c694493779d9750bb197b4db38f914.isJsActive }}
<app-tabs #app68e62aaa46c694493779d9750bb197b4db38f914></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; SequelizeModule &#125; from &#39;@nestjs/sequelize&#39;;
import &#123; User &#125; from &#39;./user.entity&#39;;

@Module(&#123;
  imports: [SequelizeModule.forFeature([User])],
  exports: [SequelizeModule]
&#125;)
export class UsersModule &#123;&#125;
</code></pre><p>Now if we import <code>UsersModule</code> in <code>UserHttpModule</code>, we can use <code>@InjectModel(User)</code> in the providers of the latter module.</p>

<span class="filename">
  {{ 'users-http.module' | extension: app1dc77598495efa5f693bad3cc307e095c5306795.isJsActive }}
<app-tabs #app1dc77598495efa5f693bad3cc307e095c5306795></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; UsersModule &#125; from &#39;./users.module&#39;;
import &#123; UsersService &#125; from &#39;./users.service&#39;;
import &#123; UsersController &#125; from &#39;./users.controller&#39;;

@Module(&#123;
  imports: [UsersModule],
  providers: [UsersService],
  controllers: [UsersController]
&#125;)
export class UserHttpModule &#123;&#125;
</code></pre><h4 appAnchor id="relations-1"><span>Relations</span></h4>
<p>Relations are associations established between two or more tables. Relations are based on common fields from each table, often involving primary and foreign keys.</p>
<p>There are three types of relations:</p>
<table>
  <tr>
    <td><code>One-to-one</code></td>
    <td>Every row in the primary table has one and only one associated row in the foreign table</td>
  </tr>
  <tr>
    <td><code>One-to-many / Many-to-one</code></td>
    <td>Every row in the primary table has one or more related rows in the foreign table</td>
  </tr>
  <tr>
    <td><code>Many-to-many</code></td>
    <td>Every row in the primary table has many related rows in the foreign table, and every record in the foreign table has many related rows in the primary table</td>
  </tr>
</table>

<p>To define relations in models, use the corresponding <strong>decorators</strong>. For example, to define that each <code>User</code> can have multiple photos, use the <code>@HasMany()</code> decorator.</p>

<span class="filename">
  {{ 'user.model' | extension: appf2efede2906e5dfa7c0edde79be4c197f1fd156e.isJsActive }}
<app-tabs #appf2efede2906e5dfa7c0edde79be4c197f1fd156e></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Column, Model, Table, HasMany &#125; from &#39;sequelize-typescript&#39;;
import &#123; Photo &#125; from &#39;../photos/photo.model&#39;;

@Table
export class User extends Model &#123;
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column(&#123; defaultValue: true &#125;)
  isActive: boolean;

  @HasMany(() =&gt; Photo)
  photos: Photo[];
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> To learn more about associations in Sequelize, read <a rel='nofollow' target='_blank' href="https://github.com/RobinBuschmann/sequelize-typescript#model-association">this</a> chapter.
</blockquote>
<h4 appAnchor id="auto-load-models"><span>Auto-load models</span></h4>
<p>Manually adding models to the <code>models</code> array of the connection options can be tedious. In addition, referencing models from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To solve this issue, automatically load models by setting both <code>autoLoadModels</code> and <code>synchronize</code> properties of the configuration object (passed into the <code>forRoot()</code> method) to <code>true</code>, as shown below:</p>

<span class="filename">
  {{ 'app.module' | extension: app4c809e9f27a2d7fd633dd57aa81bebc3a1570ebc.isJsActive }}
<app-tabs #app4c809e9f27a2d7fd633dd57aa81bebc3a1570ebc></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; SequelizeModule &#125; from &#39;@nestjs/sequelize&#39;;

@Module(&#123;
  imports: [
    SequelizeModule.forRoot(&#123;
      ...
      autoLoadModels: true,
      synchronize: true,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre><p>With that option specified, every model registered through the <code>forFeature()</code> method will be automatically added to the <code>models</code> array of the configuration object.</p>
<blockquote class="
warning "><strong>Warning</strong> Note that models that aren&#39;t registered through the <code>forFeature()</code> method, but are only referenced from the model (via an association), won&#39;t be included.
</blockquote>
<h4 appAnchor id="sequelize-transactions"><span>Sequelize Transactions</span></h4>
<p>A database transaction symbolizes a unit of work performed within a database management system against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database (<a rel='nofollow' target='_blank' href="https://en.wikipedia.org/wiki/Database_transaction">learn more</a>).</p>
<p>There are many different strategies to handle <a rel='nofollow' target='_blank' href="https://sequelize.org/v5/manual/transactions.html">Sequelize transactions</a>. Below is a sample implementation of a managed transaction (auto-callback).</p>
<p>First, we need to inject the <code>Sequelize</code> object into a class in the normal way:</p>
<pre><code class="language-typescript">
@Injectable()
export class UsersService &#123;
  constructor(private sequelize: Sequelize) &#123;&#125;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> The <code>Sequelize</code> class is imported from the <code>sequelize-typescript</code> package.
</blockquote>
<p>Now, we can use this object to create a transaction.</p>
<pre><code class="language-typescript">
async createMany() &#123;
  try &#123;
    await this.sequelize.transaction(async t =&gt; &#123;
      const transactionHost = &#123; transaction: t &#125;;

      await this.userModel.create(
          &#123; firstName: &#39;Abraham&#39;, lastName: &#39;Lincoln&#39; &#125;,
          transactionHost,
      );
      await this.userModel.create(
          &#123; firstName: &#39;John&#39;, lastName: &#39;Boothe&#39; &#125;,
          transactionHost,
      );
    &#125;);
  &#125; catch (err) &#123;
    // Transaction has been rolled back
    // err is whatever rejected the promise chain returned to the transaction callback
  &#125;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Note that the <code>Sequelize</code> instance is used only to start the transaction. However, to test this class would require mocking the entire <code>Sequelize</code> object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., <code>TransactionRunner</code>) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.
</blockquote>
<h4 appAnchor id="migrations-1"><span>Migrations</span></h4>
<p><a rel='nofollow' target='_blank' href="https://sequelize.org/v5/manual/migrations.html">Migrations</a> provide a way to incrementally update the database schema to keep it in sync with the application&#39;s data model while preserving existing data in the database. To generate, run, and revert migrations, Sequelize provides a dedicated <a rel='nofollow' target='_blank' href="https://sequelize.org/v5/manual/migrations.html#the-cli">CLI</a>.</p>
<p>Migration classes are separate from the Nest application source code. Their lifecycle is maintained by the Sequelize CLI. Therefore, you are not able to leverage dependency injection and other Nest specific features with migrations. To learn more about migrations, follow the guide in the <a rel='nofollow' target='_blank' href="https://sequelize.org/v5/manual/migrations.html#the-cli">Sequelize documentation</a>.</p>
<p><app-banner-courses></app-banner-courses></p>
<h4 appAnchor id="multiple-databases-1"><span>Multiple databases</span></h4>
<p>Some projects require multiple database connections. This can also be achieved with this module. To work with multiple connections, first create the connections. In this case, connection naming becomes <strong>mandatory</strong>.</p>
<p>Suppose you have an <code>Album</code> entity stored in its own database.</p>
<pre><code class="language-typescript">
const defaultOptions = &#123;
  dialect: &#39;postgres&#39;,
  port: 5432,
  username: &#39;user&#39;,
  password: &#39;password&#39;,
  database: &#39;db&#39;,
  synchronize: true,
&#125;;

@Module(&#123;
  imports: [
    SequelizeModule.forRoot(&#123;
      ...defaultOptions,
      host: &#39;user_db_host&#39;,
      models: [User],
    &#125;),
    SequelizeModule.forRoot(&#123;
      ...defaultOptions,
      name: &#39;albumsConnection&#39;,
      host: &#39;album_db_host&#39;,
      models: [Album],
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<blockquote class="
warning "><strong>Notice</strong> If you don&#39;t set the <code>name</code> for a connection, its name is set to <code>default</code>. Please note that you shouldn&#39;t have multiple connections without a name, or with the same name, otherwise they will get overridden.
</blockquote>
<p>At this point, you have <code>User</code> and <code>Album</code> models registered with their own connection. With this setup, you have to tell the <code>SequelizeModule.forFeature()</code> method and the <code>@InjectModel()</code> decorator which connection should be used. If you do not pass any connection name, the <code>default</code> connection is used.</p>
<pre><code class="language-typescript">
@Module(&#123;
  imports: [
    SequelizeModule.forFeature([User]),
    SequelizeModule.forFeature([Album], &#39;albumsConnection&#39;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>You can also inject the <code>Sequelize</code> instance for a given connection:</p>
<pre><code class="language-typescript">
@Injectable()
export class AlbumsService &#123;
  constructor(
    @InjectConnection(&#39;albumsConnection&#39;)
    private sequelize: Sequelize,
  ) &#123;&#125;
&#125;
</code></pre>
<p>It&#39;s also possible to inject any <code>Sequelize</code> instance to the providers:</p>
<pre><code class="language-typescript">
@Module(&#123;
  providers: [
    &#123;
      provide: AlbumsService,
      useFactory: (albumsSequelize: Sequelize) =&gt; &#123;
        return new AlbumsService(albumsSequelize);
      &#125;,
      inject: [getDataSourceToken(&#39;albumsConnection&#39;)],
    &#125;,
  ],
&#125;)
export class AlbumsModule &#123;&#125;
</code></pre>
<h4 appAnchor id="testing-1"><span>Testing</span></h4>
<p>When it comes to unit testing an application, we usually want to avoid making a database connection, keeping our test suites independent and their execution process as fast as possible. But our classes might depend on models that are pulled from the connection instance. How do we handle that? The solution is to create mock models. In order to achieve that, we set up <a routerLink="/fundamentals/custom-providers">custom providers</a>. Each registered model is automatically represented by a <code>&lt;ModelName&gt;Model</code> token, where <code>ModelName</code> is the name of your model class.</p>
<p>The <code>@nestjs/sequelize</code> package exposes the <code>getModelToken()</code> function which returns a prepared token based on a given model.</p>
<pre><code class="language-typescript">
@Module(&#123;
  providers: [
    UsersService,
    &#123;
      provide: getModelToken(User),
      useValue: mockModel,
    &#125;,
  ],
&#125;)
export class UsersModule &#123;&#125;
</code></pre>
<p>Now a substitute <code>mockModel</code> will be used as the <code>UserModel</code>. Whenever any class asks for <code>UserModel</code> using an <code>@InjectModel()</code> decorator, Nest will use the registered <code>mockModel</code> object.</p>
<h4 appAnchor id="async-configuration-1"><span>Async configuration</span></h4>
<p>You may want to pass your <code>SequelizeModule</code> options asynchronously instead of statically. In this case, use the <code>forRootAsync()</code> method, which provides several ways to deal with async configuration.</p>
<p>One approach is to use a factory function:</p>
<pre><code class="language-typescript">
SequelizeModule.forRootAsync(&#123;
  useFactory: () =&gt; (&#123;
    dialect: &#39;mysql&#39;,
    host: &#39;localhost&#39;,
    port: 3306,
    username: &#39;root&#39;,
    password: &#39;root&#39;,
    database: &#39;test&#39;,
    models: [],
  &#125;),
&#125;);
</code></pre>
<p>Our factory behaves like any other <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/fundamentals/async-providers">asynchronous provider</a> (e.g., it can be <code>async</code> and it&#39;s able to inject dependencies through <code>inject</code>).</p>
<pre><code class="language-typescript">
SequelizeModule.forRootAsync(&#123;
  imports: [ConfigModule],
  useFactory: (configService: ConfigService) =&gt; (&#123;
    dialect: &#39;mysql&#39;,
    host: configService.get(&#39;HOST&#39;),
    port: +configService.get(&#39;PORT&#39;),
    username: configService.get(&#39;USERNAME&#39;),
    password: configService.get(&#39;PASSWORD&#39;),
    database: configService.get(&#39;DATABASE&#39;),
    models: [],
  &#125;),
  inject: [ConfigService],
&#125;);
</code></pre>
<p>Alternatively, you can use the <code>useClass</code> syntax:</p>
<pre><code class="language-typescript">
SequelizeModule.forRootAsync(&#123;
  useClass: SequelizeConfigService,
&#125;);
</code></pre>
<p>The construction above will instantiate <code>SequelizeConfigService</code> inside <code>SequelizeModule</code> and use it to provide an options object by calling <code>createSequelizeOptions()</code>. Note that this means that the <code>SequelizeConfigService</code> has to implement the <code>SequelizeOptionsFactory</code> interface, as shown below:</p>
<pre><code class="language-typescript">
@Injectable()
class SequelizeConfigService implements SequelizeOptionsFactory &#123;
  createSequelizeOptions(): SequelizeModuleOptions &#123;
    return &#123;
      dialect: &#39;mysql&#39;,
      host: &#39;localhost&#39;,
      port: 3306,
      username: &#39;root&#39;,
      password: &#39;root&#39;,
      database: &#39;test&#39;,
      models: [],
    &#125;;
  &#125;
&#125;
</code></pre>
<p>In order to prevent the creation of <code>SequelizeConfigService</code> inside <code>SequelizeModule</code> and use a provider imported from a different module, you can use the <code>useExisting</code> syntax.</p>
<pre><code class="language-typescript">
SequelizeModule.forRootAsync(&#123;
  imports: [ConfigModule],
  useExisting: ConfigService,
&#125;);
</code></pre>
<p>This construction works the same as <code>useClass</code> with one critical difference - <code>SequelizeModule</code> will lookup imported modules to reuse an existing <code>ConfigService</code> instead of instantiating a new one.</p>
<h4 appAnchor id="example-1"><span>Example</span></h4>
<p>A working example is available <a rel='nofollow' target='_blank' href="https://github.com/nestjs/nest/tree/master/sample/07-sequelize">here</a>.</p>

</div>

