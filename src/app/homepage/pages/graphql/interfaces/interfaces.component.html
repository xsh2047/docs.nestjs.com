
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/interfaces.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="interfaces">Interfaces</h3>
<p>Like many type systems, GraphQL supports interfaces. An <strong>Interface</strong> is an abstract type that includes a certain set of fields that a type must include to implement the interface (read more <a rel='nofollow' target='_blank' href="https://graphql.org/learn/schema/#interfaces">here</a>).</p>
<h4 appAnchor id="code-first"><span>Code first</span></h4>
<p>When using the code first approach, you define a GraphQL interface by creating an abstract class annotated with the <code>@InterfaceType()</code> decorator exported from the <code>@nestjs/graphql</code>.</p>
<pre><code class="language-typescript">
import &#123; Field, ID, InterfaceType &#125; from &#39;@nestjs/graphql&#39;;

@InterfaceType()
export abstract class Character &#123;
  @Field((type) =&gt; ID)
  id: string;

  @Field()
  name: string;
&#125;
</code></pre>
<blockquote class="
warning "><strong>Warning</strong> TypeScript interfaces cannot be used to define GraphQL interfaces.
</blockquote>
<p>This will result in generating the following part of the GraphQL schema in SDL:</p>
<pre><code class="language-graphql">
interface Character &#123;
  id: ID!
  name: String!
&#125;
</code></pre>
<p>Now, to implement the <code>Character</code> interface, use the <code>implements</code> key:</p>
<pre><code class="language-typescript">
@ObjectType(&#123;
  implements: () =&gt; [Character],
&#125;)
export class Human implements Character &#123;
  id: string;
  name: string;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> The <code>@ObjectType()</code> decorator is exported from the <code>@nestjs/graphql</code> package.
</blockquote>
<p>The default <code>resolveType()</code> function generated by the library extracts the type based on the value returned from the resolver method. This means that you must return class instances (you cannot return literal JavaScript objects).</p>
<p>To provide a customized <code>resolveType()</code> function, pass the <code>resolveType</code> property to the options object passed into the <code>@InterfaceType()</code> decorator, as follows:</p>
<pre><code class="language-typescript">
@InterfaceType(&#123;
  resolveType(book) &#123;
    if (book.colors) &#123;
      return ColoringBook;
    &#125;
    return TextBook;
  &#125;,
&#125;)
export abstract class Book &#123;
  @Field((type) =&gt; ID)
  id: string;

  @Field()
  title: string;
&#125;
</code></pre>
<h4 appAnchor id="interface-resolvers"><span>Interface resolvers</span></h4>
<p>So far, using interfaces, you could only share field definitions with your objects. If you also want to share the actual field resolvers implementation, you can create a dedicated interface resolver, as follows:</p>
<pre><code class="language-typescript">
import &#123; Resolver, ResolveField, Parent, Info &#125; from &#39;@nestjs/graphql&#39;;

@Resolver(type =&gt; Character) // Reminder: Character is an interface
export class CharacterInterfaceResolver &#123;
  @ResolveField(() =&gt; [Character])
  friends(
    @Parent() character, // Resolved object that implements Character
    @Info() &#123; parentType &#125;, // Type of the object that implements Character
    @Args(&#39;search&#39;, &#123; type: () =&gt; String &#125;) searchTerm: string,
  ) &#123;
    // Get character&#39;s friends
    return [];
  &#125;
&#125;
</code></pre>
<p>Now the <code>friends</code> field resolver is auto-registered for all object types that implement the <code>Character</code> interface.</p>
<h4 appAnchor id="schema-first"><span>Schema first</span></h4>
<p>To define an interface in the schema first approach, simply create a GraphQL interface with SDL.</p>
<pre><code class="language-graphql">
interface Character &#123;
  id: ID!
  name: String!
&#125;
</code></pre>
<p>Then, you can use the typings generation feature (as shown in the <a routerLink="/graphql/quick-start">quick start</a> chapter) to generate corresponding TypeScript definitions:</p>
<pre><code class="language-typescript">
export interface Character &#123;
  id: string;
  name: string;
&#125;
</code></pre>
<p>Interfaces require an extra <code>__resolveType</code> field in the resolver map to determine which type the interface should resolve to. Let&#39;s create a <code>CharactersResolver</code> class and define the <code>__resolveType</code> method:</p>
<pre><code class="language-typescript">
@Resolver(&#39;Character&#39;)
export class CharactersResolver &#123;
  @ResolveField()
  __resolveType(value) &#123;
    if (&#39;age&#39; in value) &#123;
      return Person;
    &#125;
    return null;
  &#125;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> All decorators are exported from the <code>@nestjs/graphql</code> package.
</blockquote>

</div>

