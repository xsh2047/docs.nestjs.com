
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/scalars.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="scalars">Scalars</h3>
<p>A GraphQL object type has a name and fields, but at some point those fields have to resolve to some concrete data. That&#39;s where the scalar types come in: they represent the leaves of the query (read more <a rel='nofollow' target='_blank' href="https://graphql.org/learn/schema/#scalar-types">here</a>). GraphQL includes the following default types: <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code> and <code>ID</code>. In addition to these built-in types, you may need to support custom atomic data types (e.g., <code>Date</code>).</p>
<h4 appAnchor id="code-first"><span>Code first</span></h4>
<p>The code-first approach ships with five scalars in which three of them are simple aliases for the existing GraphQL types.</p>
<ul>
<li><code>ID</code> (alias for <code>GraphQLID</code>) - represents a unique identifier, often used to refetch an object or as the key for a cache</li>
<li><code>Int</code> (alias for <code>GraphQLInt</code>) - a signed 32‐bit integer</li>
<li><code>Float</code> (alias for <code>GraphQLFloat</code>) - a signed double-precision floating-point value</li>
<li><code>GraphQLISODateTime</code> - a date-time string at UTC (used by default to represent <code>Date</code> type)</li>
<li><code>GraphQLTimestamp</code> - a signed integer which represents date and time as number of milliseconds from start of UNIX epoch</li>
</ul>
<p>The <code>GraphQLISODateTime</code> (e.g. <code>2019-12-03T09:54:33Z</code>) is used by default to represent the <code>Date</code> type. To use the <code>GraphQLTimestamp</code> instead, set the <code>dateScalarMode</code> of the <code>buildSchemaOptions</code> object to <code>&#39;timestamp&#39;</code> as follows:</p>
<pre><code class="language-typescript">
GraphQLModule.forRoot(&#123;
  buildSchemaOptions: &#123;
    dateScalarMode: &#39;timestamp&#39;,
  &#125;
&#125;),
</code></pre>
<p>Likewise, the <code>GraphQLFloat</code> is used by default to represent the <code>number</code> type. To use the <code>GraphQLInt</code> instead, set the <code>numberScalarMode</code> of the <code>buildSchemaOptions</code> object to <code>&#39;integer&#39;</code> as follows:</p>
<pre><code class="language-typescript">
GraphQLModule.forRoot(&#123;
  buildSchemaOptions: &#123;
    numberScalarMode: &#39;integer&#39;,
  &#125;
&#125;),
</code></pre>
<p>In addition, you can create custom scalars.</p>
<h4 appAnchor id="override-a-default-scalar"><span>Override a default scalar</span></h4>
<p>To create a custom implementation for the <code>Date</code> scalar, simply create a new class.</p>
<pre><code class="language-typescript">
import &#123; Scalar, CustomScalar &#125; from &#39;@nestjs/graphql&#39;;
import &#123; Kind, ValueNode &#125; from &#39;graphql&#39;;

@Scalar(&#39;Date&#39;, (type) =&gt; Date)
export class DateScalar implements CustomScalar&lt;number, Date&gt; &#123;
  description = &#39;Date custom scalar type&#39;;

  parseValue(value: number): Date &#123;
    return new Date(value); // value from the client
  &#125;

  serialize(value: Date): number &#123;
    return value.getTime(); // value sent to the client
  &#125;

  parseLiteral(ast: ValueNode): Date &#123;
    if (ast.kind === Kind.INT) &#123;
      return new Date(ast.value);
    &#125;
    return null;
  &#125;
&#125;
</code></pre>
<p>With this in place, register <code>DateScalar</code> as a provider.</p>
<pre><code class="language-typescript">
@Module(&#123;
  providers: [DateScalar],
&#125;)
export class CommonModule &#123;&#125;
</code></pre>
<p>Now we can use the <code>Date</code> type in our classes.</p>
<pre><code class="language-typescript">
@Field()
creationDate: Date;
</code></pre>
<h4 appAnchor id="import-a-custom-scalar"><span>Import a custom scalar</span></h4>
<p>To use a custom scalar, import and register it as a resolver. We’ll use the <code>graphql-type-json</code> package for demonstration purposes. This npm package defines a <code>JSON</code> GraphQL scalar type.</p>
<p>Start by installing the package:</p>
<pre><code class="language-bash">
$ npm i --save graphql-type-json
</code></pre>
<p>Once the package is installed, we pass a custom resolver to the <code>forRoot()</code> method:</p>
<pre><code class="language-typescript">
import GraphQLJSON from &#39;graphql-type-json&#39;;

@Module(&#123;
  imports: [
    GraphQLModule.forRoot(&#123;
      resolvers: &#123; JSON: GraphQLJSON &#125;,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>Now we can use the <code>JSON</code> type in our classes.</p>
<pre><code class="language-typescript">
@Field((type) =&gt; GraphQLJSON)
info: JSON;
</code></pre>
<p>For a suite of useful scalars, take a look at the <a rel='nofollow' target='_blank' href="https://www.npmjs.com/package/graphql-scalars">graphql-scalars</a> package.</p>
<h4 appAnchor id="create-a-custom-scalar"><span>Create a custom scalar</span></h4>
<p>To define a custom scalar, create a new <code>GraphQLScalarType</code> instance. We&#39;ll create a custom <code>UUID</code> scalar.</p>
<pre><code class="language-typescript">
const regex = /^[0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;12&#125;$/i;

function validate(uuid: unknown): string | never &#123;
  if (typeof uuid !== &quot;string&quot; || !regex.test(uuid)) &#123;
    throw new Error(&quot;invalid uuid&quot;);
  &#125;
  return uuid;
&#125;

export const CustomUuidScalar = new GraphQLScalarType(&#123;
  name: &#39;UUID&#39;,
  description: &#39;A simple UUID parser&#39;,
  serialize: (value) =&gt; validate(value),
  parseValue: (value) =&gt; validate(value),
  parseLiteral: (ast) =&gt; validate(ast.value)
&#125;)
</code></pre>
<p>We pass a custom resolver to the <code>forRoot()</code> method:</p>
<pre><code class="language-typescript">
@Module(&#123;
  imports: [
    GraphQLModule.forRoot(&#123;
      resolvers: &#123; UUID: CustomUuidScalar &#125;,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>Now we can use the <code>UUID</code> type in our classes.</p>
<pre><code class="language-typescript">
@Field((type) =&gt; CustomUuidScalar)
uuid: string;
</code></pre>
<h4 appAnchor id="schema-first"><span>Schema first</span></h4>
<p>To define a custom scalar (read more about scalars <a rel='nofollow' target='_blank' href="https://www.apollographql.com/docs/graphql-tools/scalars.html">here</a>), create a type definition and a dedicated resolver. Here (as in the official documentation), we’ll use the <code>graphql-type-json</code> package for demonstration purposes. This npm package defines a <code>JSON</code> GraphQL scalar type.</p>
<p>Start by installing the package:</p>
<pre><code class="language-bash">
$ npm i --save graphql-type-json
</code></pre>
<p>Once the package is installed, we pass a custom resolver to the <code>forRoot()</code> method:</p>
<pre><code class="language-typescript">
import GraphQLJSON from &#39;graphql-type-json&#39;;

@Module(&#123;
  imports: [
    GraphQLModule.forRoot(&#123;
      typePaths: [&#39;./**/*.graphql&#39;],
      resolvers: &#123; JSON: GraphQLJSON &#125;,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>Now we can use the <code>JSON</code> scalar in our type definitions:</p>
<pre><code class="language-graphql">
scalar JSON

type Foo &#123;
  field: JSON
&#125;
</code></pre>
<p>Another method to define a scalar type is to create a simple class. Assume we want to enhance our schema with the <code>Date</code> type.</p>
<pre><code class="language-typescript">
import &#123; Scalar, CustomScalar &#125; from &#39;@nestjs/graphql&#39;;
import &#123; Kind, ValueNode &#125; from &#39;graphql&#39;;

@Scalar(&#39;Date&#39;)
export class DateScalar implements CustomScalar&lt;number, Date&gt; &#123;
  description = &#39;Date custom scalar type&#39;;

  parseValue(value: number): Date &#123;
    return new Date(value); // value from the client
  &#125;

  serialize(value: Date): number &#123;
    return value.getTime(); // value sent to the client
  &#125;

  parseLiteral(ast: ValueNode): Date &#123;
    if (ast.kind === Kind.INT) &#123;
      return new Date(ast.value);
    &#125;
    return null;
  &#125;
&#125;
</code></pre>
<p>With this in place, register <code>DateScalar</code> as a provider.</p>
<pre><code class="language-typescript">
@Module(&#123;
  providers: [DateScalar],
&#125;)
export class CommonModule &#123;&#125;
</code></pre>
<p>Now we can use the <code>Date</code> scalar in type definitions.</p>
<pre><code class="language-graphql">
scalar Date
</code></pre>
<p>By default, the generated TypeScript definition for all scalars is <code>any</code> - which isn&#39;t particularly typesafe.
But, you can configure how Nest generates typings for your custom scalars when you specify how to generate types:</p>
<pre><code class="language-typescript">
import &#123; GraphQLDefinitionsFactory &#125; from &#39;@nestjs/graphql&#39;;
import &#123; join &#125; from &#39;path&#39;;

const definitionsFactory = new GraphQLDefinitionsFactory();

definitionsFactory.generate(&#123;
  typePaths: [&#39;./src/**/*.graphql&#39;],
  path: join(process.cwd(), &#39;src/graphql.ts&#39;),
  outputAs: &#39;class&#39;,
  defaultScalarType: &#39;unknown&#39;,
  customScalarTypeMapping: &#123;
    DateTime: &#39;Date&#39;,
    BigNumber: &#39;_BigNumber&#39;,
  &#125;,
  additionalHeader: &quot;import _BigNumber from &#39;bignumber.js&#39;&quot;,
&#125;);
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Alternatively, you can use a type reference instead, for example: <code>DateTime: Date</code>. In this case, <code>GraphQLDefinitionsFactory</code> will extract the name property of the specified type (<code>Date.name</code>) to generate TS definitions. Note: adding an import statement for non-built-in types (custom types) is required.
</blockquote>
<p>Now, given the following GraphQL custom scalar types:</p>
<pre><code class="language-graphql">
scalar DateTime
scalar BigNumber
scalar Payload
</code></pre>
<p>We will now see the following generated TypeScript definitions in <code>src/graphql.ts</code>:</p>
<pre><code class="language-typescript">
import _BigNumber from &#39;bignumber.js&#39;;

export type DateTime = Date;
export type BigNumber = _BigNumber;
export type Payload = unknown;
</code></pre>
<p>Here, we&#39;ve used the <code>customScalarTypeMapping</code> property to supply a map of the types we wish to declare for our custom scalars. We&#39;ve
also provided an <code>additionalHeader</code> property so that we can add any imports required for these type definitions. Lastly, we&#39;ve added
a <code>defaultScalarType</code> of <code>&#39;unknown&#39;</code>, so that any custom scalars not specified in <code>customScalarTypeMapping</code> will be aliased to
<code>unknown</code> instead of <code>any</code> (which <a rel='nofollow' target='_blank' href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">TypeScript recommends</a> using since 3.0 for added type safety).</p>
<blockquote class="
info "><strong>Hint</strong> Note that we&#39;ve imported <code>_BigNumber</code> from <code>bignumber.js</code>; this is to avoid <a rel='nofollow' target='_blank' href="https://github.com/Microsoft/TypeScript/issues/12525#issuecomment-263166239">circular type references</a>.
</blockquote>

</div>

