
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/graphql/unions-and-enums.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="unions">Unions</h3>
<p>Union types are very similar to interfaces, but they don&#39;t get to specify any common fields between the types (read more <a rel='nofollow' target='_blank' href="https://graphql.org/learn/schema/#union-types">here</a>). Unions are useful for returning disjoint data types from a single field.</p>
<h4 appAnchor id="code-first"><span>Code first</span></h4>
<p>To define a GraphQL union type, we must define classes that this union will be composed of. Following the <a rel='nofollow' target='_blank' href="https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/#union-type">example</a> from the Apollo documentation, we&#39;ll create two classes. First, <code>Book</code>:</p>
<pre><code class="language-typescript">
import &#123; Field, ObjectType &#125; from &#39;@nestjs/graphql&#39;;

@ObjectType()
export class Book &#123;
  @Field()
  title: string;
&#125;
</code></pre>
<p>And then <code>Author</code>:</p>
<pre><code class="language-typescript">
import &#123; Field, ObjectType &#125; from &#39;@nestjs/graphql&#39;;

@ObjectType()
export class Author &#123;
  @Field()
  name: string;
&#125;
</code></pre>
<p>With this in place, register the <code>ResultUnion</code> union using the <code>createUnionType</code> function exported from the <code>@nestjs/graphql</code> package:</p>
<pre><code class="language-typescript">
export const ResultUnion = createUnionType(&#123;
  name: &#39;ResultUnion&#39;,
  types: () =&gt; [Author, Book] as const,
&#125;);
</code></pre>
<blockquote class="
warning "><strong>Warning</strong> The array returned by the <code>types</code> property of the <code>createUnionType</code> function should be given a const assertion. If the const assertion is not given, a wrong declaration file will be generated at compile time, and an error will occur when using it from another project.
</blockquote>
<p>Now, we can reference the <code>ResultUnion</code> in our query:</p>
<pre><code class="language-typescript">
@Query(returns =&gt; [ResultUnion])
search(): Array&lt;typeof ResultUnion&gt; &#123;
  return [new Author(), new Book()];
&#125;
</code></pre>
<p>This will result in generating the following part of the GraphQL schema in SDL:</p>
<pre><code class="language-graphql">
type Author &#123;
  name: String!
&#125;

type Book &#123;
  title: String!
&#125;

union ResultUnion = Author | Book

type Query &#123;
  search: [ResultUnion!]!
&#125;
</code></pre>
<p>The default <code>resolveType()</code> function generated by the library will extract the type based on the value returned from the resolver method. That means returning class instances instead of literal JavaScript object is obligatory.</p>
<p>To provide a customized <code>resolveType()</code> function, pass the <code>resolveType</code> property to the options object passed into the <code>createUnionType()</code> function, as follows:</p>
<pre><code class="language-typescript">
export const ResultUnion = createUnionType(&#123;
  name: &#39;ResultUnion&#39;,
  types: () =&gt; [Author, Book] as const,
  resolveType(value) &#123;
    if (value.name) &#123;
      return Author;
    &#125;
    if (value.title) &#123;
      return Book;
    &#125;
    return null;
  &#125;,
&#125;);
</code></pre>
<h4 appAnchor id="schema-first"><span>Schema first</span></h4>
<p>To define a union in the schema first approach, simply create a GraphQL union with SDL.</p>
<pre><code class="language-graphql">
type Author &#123;
  name: String!
&#125;

type Book &#123;
  title: String!
&#125;

union ResultUnion = Author | Book
</code></pre>
<p>Then, you can use the typings generation feature (as shown in the <a routerLink="/graphql/quick-start">quick start</a> chapter) to generate corresponding TypeScript definitions:</p>
<pre><code class="language-typescript">
export class Author &#123;
  name: string;
&#125;

export class Book &#123;
  title: string;
&#125;

export type ResultUnion = Author | Book;
</code></pre>
<p>Unions require an extra <code>__resolveType</code> field in the resolver map to determine which type the union should resolve to. Also, note that the <code>ResultUnionResolver</code> class has to be registered as a provider in any module. Let&#39;s create a <code>ResultUnionResolver</code> class and define the <code>__resolveType</code> method.</p>
<pre><code class="language-typescript">
@Resolver(&#39;ResultUnion&#39;)
export class ResultUnionResolver &#123;
  @ResolveField()
  __resolveType(value) &#123;
    if (value.name) &#123;
      return &#39;Author&#39;;
    &#125;
    if (value.title) &#123;
      return &#39;Book&#39;;
    &#125;
    return null;
  &#125;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> All decorators are exported from the <code>@nestjs/graphql</code> package.
</blockquote>
<h3 id="enums">Enums</h3>
<p>Enumeration types are a special kind of scalar that is restricted to a particular set of allowed values (read more <a rel='nofollow' target='_blank' href="https://graphql.org/learn/schema/#enumeration-types">here</a>). This allows you to:</p>
<ul>
<li>validate that any arguments of this type are one of the allowed values</li>
<li>communicate through the type system that a field will always be one of a finite set of values</li>
</ul>
<h4 appAnchor id="code-first-1"><span>Code first</span></h4>
<p>When using the code first approach, you define a GraphQL enum type by simply creating a TypeScript enum.</p>
<pre><code class="language-typescript">
export enum AllowedColor &#123;
  RED,
  GREEN,
  BLUE,
&#125;
</code></pre>
<p>With this in place, register the <code>AllowedColor</code> enum using the <code>registerEnumType</code> function exported from the <code>@nestjs/graphql</code> package:</p>
<pre><code class="language-typescript">
registerEnumType(AllowedColor, &#123;
  name: &#39;AllowedColor&#39;,
&#125;);
</code></pre>
<p>Now you can reference the <code>AllowedColor</code> in our types:</p>
<pre><code class="language-typescript">
@Field(type =&gt; AllowedColor)
favoriteColor: AllowedColor;
</code></pre>
<p>This will result in generating the following part of the GraphQL schema in SDL:</p>
<pre><code class="language-graphql">
enum AllowedColor &#123;
  RED
  GREEN
  BLUE
&#125;
</code></pre>
<p>To provide a description for the enum, pass the <code>description</code> property into the <code>registerEnumType()</code> function.</p>
<pre><code class="language-typescript">
registerEnumType(AllowedColor, &#123;
  name: &#39;AllowedColor&#39;,
  description: &#39;The supported colors.&#39;,
&#125;);
</code></pre>
<p>To provide a description for the enum values, or to mark a value as deprecated, pass the <code>valuesMap</code> property, as follows:</p>
<pre><code class="language-typescript">
registerEnumType(AllowedColor, &#123;
  name: &#39;AllowedColor&#39;,
  description: &#39;The supported colors.&#39;,
  valuesMap: &#123;
    RED: &#123;
      description: &#39;The default color.&#39;,
    &#125;,
    BLUE: &#123;
      deprecationReason: &#39;Too blue.&#39;,
    &#125;,
  &#125;,
&#125;);
</code></pre>
<p>This will generate the following GraphQL schema in SDL:</p>
<pre><code class="language-graphql">
&quot;&quot;&quot;
The supported colors.
&quot;&quot;&quot;
enum AllowedColor &#123;
  &quot;&quot;&quot;
  The default color.
  &quot;&quot;&quot;
  RED
  GREEN
  BLUE @deprecated(reason: &quot;Too blue.&quot;)
&#125;
</code></pre>
<h4 appAnchor id="schema-first-1"><span>Schema first</span></h4>
<p>To define an enumerator in the schema first approach, simply create a GraphQL enum with SDL.</p>
<pre><code class="language-graphql">
enum AllowedColor &#123;
  RED
  GREEN
  BLUE
&#125;
</code></pre>
<p>Then you can use the typings generation feature (as shown in the <a routerLink="/graphql/quick-start">quick start</a> chapter) to generate corresponding TypeScript definitions:</p>
<pre><code class="language-typescript">
export enum AllowedColor &#123;
  RED
  GREEN
  BLUE
&#125;
</code></pre>
<p>Sometimes a backend forces a different value for an enum internally than in the public API. In this example the API contains <code>RED</code>, however in resolvers we may use <code>#f00</code> instead (read more <a rel='nofollow' target='_blank' href="https://www.apollographql.com/docs/apollo-server/schema/scalars-enums/#internal-values">here</a>). To accomplish this, declare a resolver object for the <code>AllowedColor</code> enum:</p>
<pre><code class="language-typescript">
export const allowedColorResolver: Record&lt;keyof typeof AllowedColor, any&gt; = &#123;
  RED: &#39;#f00&#39;,
&#125;;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> All decorators are exported from the <code>@nestjs/graphql</code> package.
</blockquote>
<p>Then use this resolver object together with the <code>resolvers</code> property of the <code>GraphQLModule#forRoot()</code> method, as follows:</p>
<pre><code class="language-typescript">
GraphQLModule.forRoot(&#123;
  resolvers: &#123;
    AllowedColor: allowedColorResolver,
  &#125;,
&#125;);
</code></pre>

</div>

