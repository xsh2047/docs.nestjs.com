
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/mikroorm.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="mikroorm">MikroORM</h3>
<p>This recipe is here to help users get started with MikroORM in Nest. MikroORM is the TypeScript ORM for Node.js based on Data Mapper, Unit of Work and Identity Map patterns. It is a great alternative to TypeORM and migration from TypeORM should be fairly easy. The complete documentation on MikroORM can be found <a rel='nofollow' target='_blank' href="https://mikro-orm.io/docs">here</a>.</p>
<blockquote class="
info "><strong>info</strong> <code>@mikro-orm/nestjs</code> is a third party package and is not managed by the NestJS core team. Please report any issues found with the library in the <a rel='nofollow' target='_blank' href="https://github.com/mikro-orm/nestjs">appropriate repository</a>.
</blockquote>
<h4 appAnchor id="installation"><span>Installation</span></h4>
<p>Easiest way to integrate MikroORM to Nest is via <a rel='nofollow' target='_blank' href="https://github.com/mikro-orm/nestjs"><code>@mikro-orm/nestjs</code> module</a>.
Simply install it next to Nest, MikroORM and underlying driver:</p>
<pre><code class="language-bash">
$ npm i @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite
</code></pre>
<p>MikroORM also supports <code>postgres</code>, <code>sqlite</code>, and <code>mongo</code>. See the <a rel='nofollow' target='_blank' href="https://mikro-orm.io/docs/usage-with-sql/">official docs</a> for all drivers.</p>
<p>Once the installation process is completed, we can import the <code>MikroOrmModule</code> into the root <code>AppModule</code>.</p>
<pre><code class="language-typescript">
import &#123; SqliteDriver &#125; from &#39;@mikro-orm/sqlite&#39;;

@Module(&#123;
  imports: [
    MikroOrmModule.forRoot(&#123;
      entities: [&#39;./dist/entities&#39;],
      entitiesTs: [&#39;./src/entities&#39;],
      dbName: &#39;my-db-name.sqlite3&#39;,
      driver: SqliteDriver,
    &#125;),
  ],
  controllers: [AppController],
  providers: [AppService],
&#125;)
export class AppModule &#123;
&#125;
</code></pre>
<p>The <code>forRoot()</code> method accepts the same configuration object as <code>init()</code> from the MikroORM package. Check <a rel='nofollow' target='_blank' href="https://mikro-orm.io/docs/configuration">this page</a> for the complete configuration documentation.</p>
<p>Alternatively we can <a rel='nofollow' target='_blank' href="https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool">configure the CLI</a> by creating a configuration file <code>mikro-orm.config.ts</code> and then call the <code>forRoot()</code> without any arguments.</p>
<pre><code class="language-typescript">
@Module(&#123;
  imports: [
    MikroOrmModule.forRoot(),
  ],
  ...
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>But this won&#39;t work when you use a build tools that use tree shaking, for that it is better to provide the config explicitly:</p>
<pre><code class="language-typescript">
import config from &#39;./mikro-orm.config&#39;; // your ORM config

@Module(&#123;
  imports: [
    MikroOrmModule.forRoot(config),
  ],
  ...
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>Afterward, the <code>EntityManager</code> will be available to inject across the entire project (without importing any module elsewhere).</p>
<pre><code class="language-ts">
// Import everytyhing from your driver package or `@mikro-orm/knex`
import &#123; EntityManager, MikroORM &#125; from &#39;@mikro-orm/sqlite&#39;;

@Injectable()
export class MyService &#123;
  constructor(
    private readonly orm: MikroORM,
    private readonly em: EntityManager,
  ) &#123;&#125;
&#125;
</code></pre>
<blockquote class="
info "><strong>info</strong> Notice that the <code>EntityManager</code> is imported from the <code>@mikro-orm/driver</code> package, where driver is <code>mysql</code>, <code>sqlite</code>, <code>postgres</code> or what driver you are using. In case you have <code>@mikro-orm/knex</code> installed as a dependency, you can also import the <code>EntityManager</code> from there.
</blockquote>
<h4 appAnchor id="repositories"><span>Repositories</span></h4>
<p>MikroORM supports the repository design pattern. For every entity, we can create a repository. Read the complete documentation on repositories <a rel='nofollow' target='_blank' href="https://mikro-orm.io/docs/repositories">here</a>. To define which repositories should be registered in the current scope you can use the <code>forFeature()</code> method. For example, in this way:</p>
<blockquote class="
info "><strong>info</strong> You should <strong>not</strong> register your base entities via <code>forFeature()</code>, as there are no
repositories for those. On the other hand, base entities need to be part of the list in <code>forRoot()</code> (or in the ORM config in general).
</blockquote>
<pre><code class="language-typescript">
// photo.module.ts
@Module(&#123;
  imports: [MikroOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
&#125;)
export class PhotoModule &#123;&#125;
</code></pre>
<p>and import it into the root <code>AppModule</code>:</p>
<pre><code class="language-typescript">
// app.module.ts
@Module(&#123;
  imports: [MikroOrmModule.forRoot(...), PhotoModule],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>In this way we can inject the <code>PhotoRepository</code> to the <code>PhotoService</code> using the <code>@InjectRepository()</code> decorator:</p>
<pre><code class="language-typescript">
@Injectable()
export class PhotoService &#123;
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: EntityRepository&lt;Photo&gt;,
  ) &#123;&#125;
&#125;
</code></pre>
<h4 appAnchor id="using-custom-repositories"><span>Using custom repositories</span></h4>
<p>When using custom repositories, we no longer need the <code>@InjectRepository()</code>
decorator, as Nest DI resolved based on the class references.</p>
<pre><code class="language-ts">
// `**./author.entity.ts**`
@Entity(&#123; repository: () =&gt; AuthorRepository &#125;)
export class Author &#123;
  // to allow inference in `em.getRepository()`
  [EntityRepositoryType]?: AuthorRepository;
&#125;

// `**./author.repository.ts**`
export class AuthorRepository extends EntityRepository&lt;Author&gt; &#123;
  // your custom methods...
&#125;
</code></pre>
<p>As the custom repository name is the same as what <code>getRepositoryToken()</code> would
return, we do not need the <code>@InjectRepository()</code> decorator anymore:</p>
<pre><code class="language-ts">
@Injectable()
export class MyService &#123;
  constructor(private readonly repo: AuthorRepository) &#123;&#125;
&#125;
</code></pre>
<h4 appAnchor id="load-entities-automatically"><span>Load entities automatically</span></h4>
<p>Manually adding entities to the entities array of the connection options can be
tedious. In addition, referencing entities from the root module breaks application
domain boundaries and causes leaking implementation details to other parts of the
application. To solve this issue, static glob paths can be used.</p>
<p>Note, however, that glob paths are not supported by webpack, so if you are building
your application within a monorepo, you won&#39;t be able to use them. To address this
issue, an alternative solution is provided. To automatically load entities, set the
<code>autoLoadEntities</code> property of the configuration object (passed into the <code>forRoot()</code>
method) to <code>true</code>, as shown below:</p>
<pre><code class="language-ts">
@Module(&#123;
  imports: [
    MikroOrmModule.forRoot(&#123;
      ...
      autoLoadEntities: true,
    &#125;),
  ],
&#125;)
export class AppModule &#123;&#125;
</code></pre>
<p>With that option specified, every entity registered through the <code>forFeature()</code>
method will be automatically added to the entities array of the configuration
object.</p>
<blockquote class="
info "><strong>info</strong> Note that entities that aren&#39;t registered through the <code>forFeature()</code> method, but
are only referenced from the entity (via a relationship), won&#39;t be included by
way of the <code>autoLoadEntities</code> setting.
</blockquote>
<blockquote class="
info "><strong>info</strong> Using <code>autoLoadEntities</code> also has no effect on the MikroORM CLI - for that we
still need CLI config with the full list of entities. On the other hand, we can
use globs there, as the CLI won&#39;t go thru webpack.
</blockquote>
<h4 appAnchor id="serialization"><span>Serialization</span></h4>
<blockquote class="
warning "><strong>Note</strong> MikroORM wraps every single entity relation in a <code>Reference&lt;T&gt;</code> or a <code>Collection&lt;T&gt;</code> object, in order to provide better type-safety. This will make <a href="/techniques/serialization">Nest&#39;s built-in serializer</a> blind to any wrapped relations. In other words, if you return MikroORM entities from your HTTP or WebSocket handlers, all of their relations will NOT be serialized.
</blockquote>
<p>Luckily, MikroORM provides a <a rel='nofollow' target='_blank' href="https://mikro-orm.io/docs/serializing">serialization API</a> which can be used in lieu of <code>ClassSerializerInterceptor</code>.</p>
<pre><code class="language-typescript">
@Entity()
export class Book &#123;
  @Property(&#123; hidden: true &#125;) // Equivalent of class-transformer&#39;s `@Exclude`
  hiddenField = Date.now();

  @Property(&#123; persist: false &#125;) // Similar to class-transformer&#39;s `@Expose()`. Will only exist in memory, and will be serialized.
  count?: number;

  @ManyToOne(&#123;
    serializer: (value) =&gt; value.name,
    serializedName: &#39;authorName&#39;,
  &#125;) // Equivalent of class-transformer&#39;s `@Transform()`
  author: Author;
&#125;
</code></pre>
<h4 appAnchor id="request-scoped-handlers-in-queues"><span>Request scoped handlers in queues</span></h4>
<p>As mentioned in the <a rel='nofollow' target='_blank' href="https://mikro-orm.io/docs/identity-map">docs</a>, we need a clean state for each request. That is handled automatically thanks to the <code>RequestContext</code> helper registered via middleware.</p>
<p>But middlewares are executed only for regular HTTP request handles, what if we need
a request scoped method outside of that? One example of that is queue handlers or
scheduled tasks.</p>
<p>We can use the <code>@CreateRequestContext()</code> decorator. It requires you to first inject the
<code>MikroORM</code> instance to current context, it will be then used to create the context
for you. Under the hood, the decorator will register new request context for your
method and execute it inside the context.</p>
<pre><code class="language-ts">
@Injectable()
export class MyService &#123;
  constructor(private readonly orm: MikroORM) &#123;&#125;

  @CreateRequestContext()
  async doSomething() &#123;
    // this will be executed in a separate context
  &#125;
&#125;
</code></pre>
<blockquote class="
warning "><strong>Note</strong> As the name suggests, this decorator always creates new context, as opposed to its alternative <code>@EnsureRequestContext</code> that only creates it if it&#39;s already not inside another one.
</blockquote>
<h4 appAnchor id="testing"><span>Testing</span></h4>
<p>The <code>@mikro-orm/nestjs</code> package exposes <code>getRepositoryToken()</code> function that returns prepared token based on a given entity to allow mocking the repository.</p>
<pre><code class="language-typescript">
@Module(&#123;
  providers: [
    PhotoService,
    &#123;
      // or when you have a custom repository: `provide: PhotoRepository`
      provide: getRepositoryToken(Photo), 
      useValue: mockedRepository,
    &#125;,
  ],
&#125;)
export class PhotoModule &#123;&#125;
</code></pre>
<h4 appAnchor id="example"><span>Example</span></h4>
<p>A real world example of NestJS with MikroORM can be found <a rel='nofollow' target='_blank' href="https://github.com/mikro-orm/nestjs-realworld-example-app">here</a></p>

</div>

