
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/recipes/sql-typeorm.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="sql-typeorm">SQL (TypeORM)</h3>
<h5 id="this-chapter-applies-only-to-typescript">This chapter applies only to TypeScript</h5>
<blockquote class="
"><strong>Warning</strong> In this article, you&#39;ll learn how to create a <code>DatabaseModule</code> based on the <strong>TypeORM</strong> package from scratch using custom providers mechanism. As a consequence, this solution contains a lot of overhead that you can omit using ready to use and available out-of-the-box dedicated <code>@nestjs/typeorm</code> package. To learn more, see <a routerLink="/techniques/sql">here</a>.
</blockquote>
<p><a rel='nofollow' target='_blank' href="https://github.com/typeorm/typeorm">TypeORM</a> is definitely the most mature Object Relational Mapper (ORM) available in the node.js world. Since it&#39;s written in TypeScript, it works pretty well with the Nest framework.</p>
<h4 appAnchor id="getting-started"><span>Getting started</span></h4>
<p>To start the adventure with this library we have to install all required dependencies:</p>
<pre><code class="language-bash">
$ npm install --save typeorm mysql2
</code></pre>
<p>The first step we need to do is to establish the connection with our database using <code>new DataSource().initialize()</code> class imported from the <code>typeorm</code> package. The <code>initialize()</code> function returns a <code>Promise</code>, and therefore we have to create an <a routerLink="/fundamentals/async-components">async provider</a>.</p>

<span class="filename">
  {{ 'database.providers' | extension: appb34758f8d13b0efca3cbfc36960df8721b6a6010.isJsActive }}
<app-tabs #appb34758f8d13b0efca3cbfc36960df8721b6a6010></app-tabs>
</span><pre><code class="language-typescript">
import &#123; DataSource &#125; from &#39;typeorm&#39;;

export const databaseProviders = [
  &#123;
    provide: &#39;DATA_SOURCE&#39;,
    useFactory: async () =&gt; &#123;
      const dataSource = new DataSource(&#123;
        type: &#39;mysql&#39;,
        host: &#39;localhost&#39;,
        port: 3306,
        username: &#39;root&#39;,
        password: &#39;root&#39;,
        database: &#39;test&#39;,
        entities: [
            __dirname + &#39;/../**/*.entity&#123;.ts,.js&#125;&#39;,
        ],
        synchronize: true,
      &#125;);

      return dataSource.initialize();
    &#125;,
  &#125;,
];
</code></pre><blockquote class="
warning "><strong>Warning</strong> Setting <code>synchronize: true</code> shouldn&#39;t be used in production - otherwise you can lose production data.
</blockquote>
<blockquote class="
info "><strong>Hint</strong> Following best practices, we declared the custom provider in the separated file which has a <code>*.providers.ts</code> suffix.
</blockquote>
<p>Then, we need to export these providers to make them <strong>accessible</strong> for the rest of the application.</p>

<span class="filename">
  {{ 'database.module' | extension: app0fa532366bab4be451ed09de354929f029d38798.isJsActive }}
<app-tabs #app0fa532366bab4be451ed09de354929f029d38798></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; databaseProviders &#125; from &#39;./database.providers&#39;;

@Module(&#123;
  providers: [...databaseProviders],
  exports: [...databaseProviders],
&#125;)
export class DatabaseModule &#123;&#125;
</code></pre><p>Now we can inject the <code>DATA_SOURCE</code> object using <code>@Inject()</code> decorator. Each class that would depend on the <code>DATA_SOURCE</code> async provider will wait until a <code>Promise</code> is resolved.</p>
<h4 appAnchor id="repository-pattern"><span>Repository pattern</span></h4>
<p>The <a rel='nofollow' target='_blank' href="https://github.com/typeorm/typeorm">TypeORM</a> supports the repository design pattern, thus each entity has its own Repository. These repositories can be obtained from the database connection.</p>
<p>But firstly, we need at least one entity. We are going to reuse the <code>Photo</code> entity from the official documentation.</p>

<span class="filename">
  {{ 'photo.entity' | extension: appf272cb5970cdf2f6fceb4cd04a664b43fb13a27b.isJsActive }}
<app-tabs #appf272cb5970cdf2f6fceb4cd04a664b43fb13a27b></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Entity, Column, PrimaryGeneratedColumn &#125; from &#39;typeorm&#39;;

@Entity()
export class Photo &#123;
  @PrimaryGeneratedColumn()
  id: number;

  @Column(&#123; length: 500 &#125;)
  name: string;

  @Column(&#39;text&#39;)
  description: string;

  @Column()
  filename: string;

  @Column(&#39;int&#39;)
  views: number;

  @Column()
  isPublished: boolean;
&#125;
</code></pre><p>The <code>Photo</code> entity belongs to the <code>photo</code> directory. This directory represents the <code>PhotoModule</code>. Now, let&#39;s create a <strong>Repository</strong> provider:</p>

<span class="filename">
  {{ 'photo.providers' | extension: appec63464088835f39d7d6d1f02589fc743bc321c6.isJsActive }}
<app-tabs #appec63464088835f39d7d6d1f02589fc743bc321c6></app-tabs>
</span><pre><code class="language-typescript">
import &#123; DataSource &#125; from &#39;typeorm&#39;;
import &#123; Photo &#125; from &#39;./photo.entity&#39;;

export const photoProviders = [
  &#123;
    provide: &#39;PHOTO_REPOSITORY&#39;,
    useFactory: (dataSource: DataSource) =&gt; dataSource.getRepository(Photo),
    inject: [&#39;DATA_SOURCE&#39;],
  &#125;,
];
</code></pre><blockquote class="
warning "><strong>Warning</strong> In the real-world applications you should avoid <strong>magic strings</strong>. Both <code>PHOTO_REPOSITORY</code> and <code>DATA_SOURCE</code> should be kept in the separated <code>constants.ts</code> file.
</blockquote>
<p>Now we can inject the <code>Repository&lt;Photo&gt;</code> to the <code>PhotoService</code> using the <code>@Inject()</code> decorator:</p>

<span class="filename">
  {{ 'photo.service' | extension: app6110133474783683d565407f77377fb5056dd270.isJsActive }}
<app-tabs #app6110133474783683d565407f77377fb5056dd270></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Injectable, Inject &#125; from &#39;@nestjs/common&#39;;
import &#123; Repository &#125; from &#39;typeorm&#39;;
import &#123; Photo &#125; from &#39;./photo.entity&#39;;

@Injectable()
export class PhotoService &#123;
  constructor(
    @Inject(&#39;PHOTO_REPOSITORY&#39;)
    private photoRepository: Repository&lt;Photo&gt;,
  ) &#123;&#125;

  async findAll(): Promise&lt;Photo[]&gt; &#123;
    return this.photoRepository.find();
  &#125;
&#125;
</code></pre><p>The database connection is <strong>asynchronous</strong>, but Nest makes this process completely invisible for the end-user. The <code>PhotoRepository</code> is waiting for the db connection, and the <code>PhotoService</code> is delayed until repository is ready to use. The entire application can start when each class is instantiated.</p>
<p>Here is a final <code>PhotoModule</code>:</p>

<span class="filename">
  {{ 'photo.module' | extension: appca9e26e62ec470dc6c81774546c1fb6cbb245c5a.isJsActive }}
<app-tabs #appca9e26e62ec470dc6c81774546c1fb6cbb245c5a></app-tabs>
</span><pre><code class="language-typescript">
import &#123; Module &#125; from &#39;@nestjs/common&#39;;
import &#123; DatabaseModule &#125; from &#39;../database/database.module&#39;;
import &#123; photoProviders &#125; from &#39;./photo.providers&#39;;
import &#123; PhotoService &#125; from &#39;./photo.service&#39;;

@Module(&#123;
  imports: [DatabaseModule],
  providers: [
    ...photoProviders,
    PhotoService,
  ],
&#125;)
export class PhotoModule &#123;&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> Do not forget to import the <code>PhotoModule</code> into the root <code>AppModule</code>.
</blockquote>

</div>

