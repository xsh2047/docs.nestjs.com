
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/custom-decorators.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="custom-route-decorators">Custom route decorators</h3>
<p>Nest is built around a language feature called <strong>decorators</strong>. Decorators are a well-known concept in a lot of commonly used programming languages, but in the JavaScript world, they&#39;re still relatively new. In order to better understand how decorators work, we recommend reading <a rel='nofollow' target='_blank' href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841">this article</a>. Here&#39;s a simple definition:</p>
<blockquote class="external">
  An ES2016 decorator is an expression which returns a function and can take a target, name and property descriptor as arguments.
  You apply it by prefixing the decorator with an <code>@</code> character and placing this at the very top of what
  you are trying to decorate. Decorators can be defined for either a class, a method or a property.
</blockquote>

<h4 appAnchor id="param-decorators"><span>Param decorators</span></h4>
<p>Nest provides a set of useful <strong>param decorators</strong> that you can use together with the HTTP route handlers. Below is a list of the provided decorators and the plain Express (or Fastify) objects they represent</p>
<table>
  <tbody>
    <tr>
      <td><code>@Request(), @Req()</code></td>
      <td><code>req</code></td>
    </tr>
    <tr>
      <td><code>@Response(), @Res()</code></td>
      <td><code>res</code></td>
    </tr>
    <tr>
      <td><code>@Next()</code></td>
      <td><code>next</code></td>
    </tr>
    <tr>
      <td><code>@Session()</code></td>
      <td><code>req.session</code></td>
    </tr>
    <tr>
      <td><code>@Param(param?: string)</code></td>
      <td><code>req.params</code> / <code>req.params[param]</code></td>
    </tr>
    <tr>
      <td><code>@Body(param?: string)</code></td>
      <td><code>req.body</code> / <code>req.body[param]</code></td>
    </tr>
    <tr>
      <td><code>@Query(param?: string)</code></td>
      <td><code>req.query</code> / <code>req.query[param]</code></td>
    </tr>
    <tr>
      <td><code>@Headers(param?: string)</code></td>
      <td><code>req.headers</code> / <code>req.headers[param]</code></td>
    </tr>
    <tr>
      <td><code>@Ip()</code></td>
      <td><code>req.ip</code></td>
    </tr>
    <tr>
      <td><code>@HostParam()</code></td>
      <td><code>req.hosts</code></td>
    </tr>
  </tbody>
</table>

<p>Additionally, you can create your own <strong>custom decorators</strong>. Why is this useful?</p>
<p>In the node.js world, it&#39;s common practice to attach properties to the <strong>request</strong> object. Then you manually extract them in each route handler, using code like the following:</p>
<pre><code class="language-typescript">
const user = req.user;
</code></pre>
<p>In order to make your code more readable and transparent, you can create a <code>@User()</code> decorator and reuse it across all of your controllers.</p>

<span class="filename">
  {{ 'user.decorator' | extension: app39162a4af3c964197c740389b16bf2243529ce85.isJsActive }}
<app-tabs #app39162a4af3c964197c740389b16bf2243529ce85></app-tabs>
</span><pre><code class="language-typescript">
import &#123; createParamDecorator, ExecutionContext &#125; from &#39;@nestjs/common&#39;;

export const User = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) =&gt; &#123;
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  &#125;,
);
</code></pre><p>Then, you can simply use it wherever it fits your requirements.</p>

<span class="filename">
<app-tabs #app740f88e51aa17022a79d2b8d9658b385a0a4c31b></app-tabs>
</span><pre [class.hide]="app740f88e51aa17022a79d2b8d9658b385a0a4c31b.isJsActive"><code class="language-typescript">
@Get()
async findOne(@User() user: UserEntity) &#123;
  console.log(user);
&#125;
</code></pre>
<pre [class.hide]="!app740f88e51aa17022a79d2b8d9658b385a0a4c31b.isJsActive"><code class="language-typescript">
@Get()
@Bind(User())
async findOne(user) &#123;
  console.log(user);
&#125;
</code></pre><h4 appAnchor id="passing-data"><span>Passing data</span></h4>
<p>When the behavior of your decorator depends on some conditions, you can use the <code>data</code> parameter to pass an argument to the decorator&#39;s factory function. One use case for this is a custom decorator that extracts properties from the request object by key. Let&#39;s assume, for example, that our <a href="techniques/authentication#implementing-passport-strategies">authentication layer</a> validates requests and attaches a user entity to the request object. The user entity for an authenticated request might look like:</p>
<pre><code class="language-json">
&#123;
  &quot;id&quot;: 101,
  &quot;firstName&quot;: &quot;Alan&quot;,
  &quot;lastName&quot;: &quot;Turing&quot;,
  &quot;email&quot;: &quot;alan@email.com&quot;,
  &quot;roles&quot;: [&quot;admin&quot;]
&#125;
</code></pre>
<p>Let&#39;s define a decorator that takes a property name as key, and returns the associated value if it exists (or undefined if it doesn&#39;t exist, or if the <code>user</code> object has not been created).</p>

<span class="filename">
  {{ 'user.decorator' | extension: app5a9175f0e82fceb4a7ae9c86f72cb9446de38a2f.isJsActive }}
<app-tabs #app5a9175f0e82fceb4a7ae9c86f72cb9446de38a2f></app-tabs>
</span><pre [class.hide]="app5a9175f0e82fceb4a7ae9c86f72cb9446de38a2f.isJsActive"><code class="language-typescript">
import &#123; createParamDecorator, ExecutionContext &#125; from &#39;@nestjs/common&#39;;

export const User = createParamDecorator(
  (data: string, ctx: ExecutionContext) =&gt; &#123;
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;

    return data ? user?.[data] : user;
  &#125;,
);
</code></pre>
<pre [class.hide]="!app5a9175f0e82fceb4a7ae9c86f72cb9446de38a2f.isJsActive"><code class="language-typescript">
import &#123; createParamDecorator &#125; from &#39;@nestjs/common&#39;;

export const User = createParamDecorator((data, ctx) =&gt; &#123;
  const request = ctx.switchToHttp().getRequest();
  const user = request.user;

  return data ? user &amp;&amp; user[data] : user;
&#125;);
</code></pre><p>Here&#39;s how you could then access a particular property via the <code>@User()</code> decorator in the controller:</p>

<span class="filename">
<app-tabs #app9c1e0ae3adc206aeb21b0ef20859c43a1b4d57b9></app-tabs>
</span><pre [class.hide]="app9c1e0ae3adc206aeb21b0ef20859c43a1b4d57b9.isJsActive"><code class="language-typescript">
@Get()
async findOne(@User(&#39;firstName&#39;) firstName: string) &#123;
  console.log(`Hello $&#123;firstName&#125;`);
&#125;
</code></pre>
<pre [class.hide]="!app9c1e0ae3adc206aeb21b0ef20859c43a1b4d57b9.isJsActive"><code class="language-typescript">
@Get()
@Bind(User(&#39;firstName&#39;))
async findOne(firstName) &#123;
  console.log(`Hello $&#123;firstName&#125;`);
&#125;
</code></pre><p>You can use this same decorator with different keys to access different properties. If the <code>user</code> object is deep or complex, this can make for easier and more readable request handler implementations.</p>
<blockquote class="
info "><strong>Hint</strong> For TypeScript users, note that <code>createParamDecorator&lt;T&gt;()</code> is a generic. This means you can explicitly enforce type safety, for example <code>createParamDecorator&lt;string&gt;((data, ctx) =&gt; ...)</code>. Alternatively, specify a parameter type in the factory function, for example <code>createParamDecorator((data: string, ctx) =&gt; ...)</code>. If you omit both, the type for <code>data</code> will be <code>any</code>.
</blockquote>
<h4 appAnchor id="working-with-pipes"><span>Working with pipes</span></h4>
<p>Nest treats custom param decorators in the same fashion as the built-in ones (<code>@Body()</code>, <code>@Param()</code> and <code>@Query()</code>). This means that pipes are executed for the custom annotated parameters as well (in our examples, the <code>user</code> argument). Moreover, you can apply the pipe directly to the custom decorator:</p>

<span class="filename">
<app-tabs #appedc6f6c910935ba283ea565f893ab0887a299111></app-tabs>
</span><pre [class.hide]="appedc6f6c910935ba283ea565f893ab0887a299111.isJsActive"><code class="language-typescript">
@Get()
async findOne(
  @User(new ValidationPipe(&#123; validateCustomDecorators: true &#125;))
  user: UserEntity,
) &#123;
  console.log(user);
&#125;
</code></pre>
<pre [class.hide]="!appedc6f6c910935ba283ea565f893ab0887a299111.isJsActive"><code class="language-typescript">
@Get()
@Bind(User(new ValidationPipe(&#123; validateCustomDecorators: true &#125;)))
async findOne(user) &#123;
  console.log(user);
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> Note that <code>validateCustomDecorators</code> option must be set to true. <code>ValidationPipe</code> does not validate arguments annotated with the custom decorators by default.
</blockquote>
<h4 appAnchor id="decorator-composition"><span>Decorator composition</span></h4>
<p>Nest provides a helper method to compose multiple decorators. For example, suppose you want to combine all decorators related to authentication into a single decorator. This could be done with the following construction:</p>

<span class="filename">
  {{ 'auth.decorator' | extension: appc5779dc97a20d0981cff03a109e4e4621874a02c.isJsActive }}
<app-tabs #appc5779dc97a20d0981cff03a109e4e4621874a02c></app-tabs>
</span><pre [class.hide]="appc5779dc97a20d0981cff03a109e4e4621874a02c.isJsActive"><code class="language-typescript">
import &#123; applyDecorators &#125; from &#39;@nestjs/common&#39;;

export function Auth(...roles: Role[]) &#123;
  return applyDecorators(
    SetMetadata(&#39;roles&#39;, roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse(&#123; description: &#39;Unauthorized&#39; &#125;),
  );
&#125;
</code></pre>
<pre [class.hide]="!appc5779dc97a20d0981cff03a109e4e4621874a02c.isJsActive"><code class="language-typescript">
import &#123; applyDecorators &#125; from &#39;@nestjs/common&#39;;

export function Auth(...roles) &#123;
  return applyDecorators(
    SetMetadata(&#39;roles&#39;, roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse(&#123; description: &#39;Unauthorized&#39; &#125;),
  );
&#125;
</code></pre><p>You can then use this custom <code>@Auth()</code> decorator as follows:</p>
<pre><code class="language-typescript">
@Get(&#39;users&#39;)
@Auth(&#39;admin&#39;)
findAllUsers() &#123;&#125;
</code></pre>
<p>This has the effect of applying all four decorators with a single declaration.</p>
<blockquote class="
warning "><strong>Warning</strong> The <code>@ApiHideProperty()</code> decorator from the <code>@nestjs/swagger</code> package is not composable and won&#39;t work properly with the <code>applyDecorators</code> function.
</blockquote>

</div>

