
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/openapi/types-and-parameters.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="types-and-parameters">Types and parameters</h3>
<p>The <code>SwaggerModule</code> searches for all <code>@Body()</code>, <code>@Query()</code>, and <code>@Param()</code> decorators in route handlers to generate the API document. It also creates corresponding model definitions by taking advantage of reflection. Consider the following code:</p>
<pre><code class="language-typescript">
@Post()
async create(@Body() createCatDto: CreateCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> To explicitly set the body definition use the <code>@ApiBody()</code> decorator (imported from the <code>@nestjs/swagger</code> package).
</blockquote>
<p>Based on the <code>CreateCatDto</code>, the following model definition Swagger UI will be created:</p>
<figure><img src="/assets/swagger-dto.png" /></figure>

<p>As you can see, the definition is empty although the class has a few declared properties. In order to make the class properties visible to the <code>SwaggerModule</code>, we have to either annotate them with the <code>@ApiProperty()</code> decorator or use the CLI plugin (read more in the <strong>Plugin</strong> section) which will do it automatically:</p>
<pre><code class="language-typescript">
import &#123; ApiProperty &#125; from &#39;@nestjs/swagger&#39;;

export class CreateCatDto &#123;
  @ApiProperty()
  name: string;

  @ApiProperty()
  age: number;

  @ApiProperty()
  breed: string;
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Instead of manually annotating each property, consider using the Swagger plugin (see <a routerLink="/openapi/cli-plugin">Plugin</a> section) which will automatically provide this for you.
</blockquote>
<p>Let&#39;s open the browser and verify the generated <code>CreateCatDto</code> model:</p>
<figure><img src="/assets/swagger-dto2.png" /></figure>

<p>In addition, the <code>@ApiProperty()</code> decorator allows setting various <a rel='nofollow' target='_blank' href="https://swagger.io/specification/#schemaObject">Schema Object</a> properties:</p>
<pre><code class="language-typescript">
@ApiProperty(&#123;
  description: &#39;The age of a cat&#39;,
  minimum: 1,
  default: 1,
&#125;)
age: number;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Instead of explicitly typing the <code>{{&quot;@ApiProperty({ required: false })&quot;}}</code> you can use the <code>@ApiPropertyOptional()</code> short-hand decorator.
</blockquote>
<p>In order to explicitly set the type of the property, use the <code>type</code> key:</p>
<pre><code class="language-typescript">
@ApiProperty(&#123;
  type: Number,
&#125;)
age: number;
</code></pre>
<h4 appAnchor id="arrays"><span>Arrays</span></h4>
<p>When the property is an array, we must manually indicate the array type as shown below:</p>
<pre><code class="language-typescript">
@ApiProperty(&#123; type: [String] &#125;)
names: string[];
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Consider using the Swagger plugin (see <a routerLink="/openapi/cli-plugin">Plugin</a> section) which will automatically detect arrays.
</blockquote>
<p>Either include the type as the first element of an array (as shown above) or set the <code>isArray</code> property to <code>true</code>.</p>
<p><app-banner-enterprise></app-banner-enterprise></p>
<h4 appAnchor id="circular-dependencies"><span>Circular dependencies</span></h4>
<p>When you have circular dependencies between classes, use a lazy function to provide the <code>SwaggerModule</code> with type information:</p>
<pre><code class="language-typescript">
@ApiProperty(&#123; type: () =&gt; Node &#125;)
node: Node;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Consider using the Swagger plugin (see <a routerLink="/openapi/cli-plugin">Plugin</a> section) which will automatically detect circular dependencies.
</blockquote>
<h4 appAnchor id="generics-and-interfaces"><span>Generics and interfaces</span></h4>
<p>Since TypeScript does not store metadata about generics or interfaces, when you use them in your DTOs, <code>SwaggerModule</code> may not be able to properly generate model definitions at runtime. For instance, the following code won&#39;t be correctly inspected by the Swagger module:</p>
<pre><code class="language-typescript">
createBulk(@Body() usersDto: CreateUserDto[])
</code></pre>
<p>In order to overcome this limitation, you can set the type explicitly:</p>
<pre><code class="language-typescript">
@ApiBody(&#123; type: [CreateUserDto] &#125;)
createBulk(@Body() usersDto: CreateUserDto[])
</code></pre>
<h4 appAnchor id="enums"><span>Enums</span></h4>
<p>To identify an <code>enum</code>, we must manually set the <code>enum</code> property on the <code>@ApiProperty</code> with an array of values.</p>
<pre><code class="language-typescript">
@ApiProperty(&#123; enum: [&#39;Admin&#39;, &#39;Moderator&#39;, &#39;User&#39;]&#125;)
role: UserRole;
</code></pre>
<p>Alternatively, define an actual TypeScript enum as follows:</p>
<pre><code class="language-typescript">
export enum UserRole &#123;
  Admin = &#39;Admin&#39;,
  Moderator = &#39;Moderator&#39;,
  User = &#39;User&#39;,
&#125;
</code></pre>
<p>You can then use the enum directly with the <code>@Query()</code> parameter decorator in combination with the <code>@ApiQuery()</code> decorator.</p>
<pre><code class="language-typescript">
@ApiQuery(&#123; name: &#39;role&#39;, enum: UserRole &#125;)
async filterByRole(@Query(&#39;role&#39;) role: UserRole = UserRole.User) &#123;&#125;
</code></pre>
<figure><img src="/assets/enum_query.gif" /></figure>

<p>With <code>isArray</code> set to <strong>true</strong>, the <code>enum</code> can be selected as a <strong>multi-select</strong>:</p>
<figure><img src="/assets/enum_query_array.gif" /></figure>

<h4 appAnchor id="enums-schema"><span>Enums schema</span></h4>
<p>By default, the <code>enum</code> property will add a raw definition of <a rel='nofollow' target='_blank' href="https://swagger.io/docs/specification/data-models/enums/">Enum</a> on the <code>parameter</code>.</p>
<pre><code class="language-yaml">
- breed:
    type: &#39;string&#39;
    enum:
      - Persian
      - Tabby
      - Siamese
</code></pre>
<p>The above specification works fine for most cases. However, if you are utilizing a tool that takes the specification as <strong>input</strong> and generates <strong>client-side</strong> code, you might run into a problem with the generated code containing duplicated <code>enums</code>. Consider the following code snippet:</p>
<pre><code class="language-typescript">
// generated client-side code
export class CatDetail &#123;
  breed: CatDetailEnum;
&#125;

export class CatInformation &#123;
  breed: CatInformationEnum;
&#125;

export enum CatDetailEnum &#123;
  Persian = &#39;Persian&#39;,
  Tabby = &#39;Tabby&#39;,
  Siamese = &#39;Siamese&#39;,
&#125;

export enum CatInformationEnum &#123;
  Persian = &#39;Persian&#39;,
  Tabby = &#39;Tabby&#39;,
  Siamese = &#39;Siamese&#39;,
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> The above snippet is generated using a tool called <a rel='nofollow' target='_blank' href="https://github.com/RicoSuter/NSwag">NSwag</a>.
</blockquote>
<p>You can see that now you have two <code>enums</code> that are exactly the same.
To address this issue, you can pass an <code>enumName</code> along with the <code>enum</code> property in your decorator.</p>
<pre><code class="language-typescript">
export class CatDetail &#123;
  @ApiProperty(&#123; enum: CatBreed, enumName: &#39;CatBreed&#39; &#125;)
  breed: CatBreed;
&#125;
</code></pre>
<p>The <code>enumName</code> property enables <code>@nestjs/swagger</code> to turn <code>CatBreed</code> into its own <code>schema</code> which in turns makes <code>CatBreed</code> enum reusable. The specification will look like the following:</p>
<pre><code class="language-yaml">
CatDetail:
  type: &#39;object&#39;
  properties:
    ...
    - breed:
        schema:
          $ref: &#39;#/components/schemas/CatBreed&#39;
CatBreed:
  type: string
  enum:
    - Persian
    - Tabby
    - Siamese
</code></pre>
<blockquote class="
info "><strong>Hint</strong> Any <strong>decorator</strong> that takes <code>enum</code> as a property will also take <code>enumName</code>.
</blockquote>
<h4 appAnchor id="raw-definitions"><span>Raw definitions</span></h4>
<p>In some specific scenarios (e.g., deeply nested arrays, matrices), you may want to describe your type by hand.</p>
<pre><code class="language-typescript">
@ApiProperty(&#123;
  type: &#39;array&#39;,
  items: &#123;
    type: &#39;array&#39;,
    items: &#123;
      type: &#39;number&#39;,
    &#125;,
  &#125;,
&#125;)
coords: number[][];
</code></pre>
<p>Likewise, in order to define your input/output content manually in controller classes, use the <code>schema</code> property:</p>
<pre><code class="language-typescript">
@ApiBody(&#123;
  schema: &#123;
    type: &#39;array&#39;,
    items: &#123;
      type: &#39;array&#39;,
      items: &#123;
        type: &#39;number&#39;,
      &#125;,
    &#125;,
  &#125;,
&#125;)
async create(@Body() coords: number[][]) &#123;&#125;
</code></pre>
<h4 appAnchor id="extra-models"><span>Extra models</span></h4>
<p>To define additional models that are not directly referenced in your controllers but should be inspected by the Swagger module, use the <code>@ApiExtraModels()</code> decorator:</p>
<pre><code class="language-typescript">
@ApiExtraModels(ExtraModel)
export class CreateCatDto &#123;&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> You only need to use <code>@ApiExtraModels()</code> once for a specific model class.
</blockquote>
<p>Alternatively, you can pass an options object with the <code>extraModels</code> property specified to the <code>SwaggerModule#createDocument()</code> method, as follows:</p>
<pre><code class="language-typescript">
const document = SwaggerModule.createDocument(app, options, &#123;
  extraModels: [ExtraModel],
&#125;);
</code></pre>
<p>To get a reference (<code>$ref</code>) to your model, use the <code>getSchemaPath(ExtraModel)</code> function:</p>
<pre><code class="language-typescript">
&#39;application/vnd.api+json&#39;: &#123;
   schema: &#123; $ref: getSchemaPath(ExtraModel) &#125;,
&#125;,
</code></pre>
<h4 appAnchor id="oneof-anyof-allof"><span>oneOf, anyOf, allOf</span></h4>
<p>To combine schemas, you can use the <code>oneOf</code>, <code>anyOf</code> or <code>allOf</code> keywords (<a rel='nofollow' target='_blank' href="https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/">read more</a>).</p>
<pre><code class="language-typescript">
@ApiProperty(&#123;
  oneOf: [
    &#123; $ref: getSchemaPath(Cat) &#125;,
    &#123; $ref: getSchemaPath(Dog) &#125;,
  ],
&#125;)
pet: Cat | Dog;
</code></pre>
<p>If you want to define a polymorphic array (i.e., an array whose members span multiple schemas), you should use a raw definition (see above) to define your type by hand.</p>
<pre><code class="language-typescript">
type Pet = Cat | Dog;

@ApiProperty(&#123;
  type: &#39;array&#39;,
  items: &#123;
    oneOf: [
      &#123; $ref: getSchemaPath(Cat) &#125;,
      &#123; $ref: getSchemaPath(Dog) &#125;,
    ],
  &#125;,
&#125;)
pets: Pet[];
</code></pre>
<blockquote class="
info "><strong>Hint</strong> The <code>getSchemaPath()</code> function is imported from <code>@nestjs/swagger</code>.
</blockquote>
<p>Both <code>Cat</code> and <code>Dog</code> must be defined as extra models using the <code>@ApiExtraModels()</code> decorator (at the class-level).</p>

</div>

