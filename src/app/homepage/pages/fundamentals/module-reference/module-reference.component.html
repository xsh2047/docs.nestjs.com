
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/module-reference.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="module-reference">Module reference</h3>
<p>Nest provides the <code>ModuleRef</code> class to navigate the internal list of providers and obtain a reference to any provider using its injection token as a lookup key. The <code>ModuleRef</code> class also provides a way to dynamically instantiate both static and scoped providers. <code>ModuleRef</code> can be injected into a class in the normal way:</p>

<span class="filename">
  {{ 'cats.service' | extension: app269892e2aa9f2990e8ea32618890f451dc60de45.isJsActive }}
<app-tabs #app269892e2aa9f2990e8ea32618890f451dc60de45></app-tabs>
</span><pre [class.hide]="app269892e2aa9f2990e8ea32618890f451dc60de45.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService &#123;
  constructor(private moduleRef: ModuleRef) &#123;&#125;
&#125;
</code></pre>
<pre [class.hide]="!app269892e2aa9f2990e8ea32618890f451dc60de45.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>ModuleRef</code> class is imported from the <code>@nestjs/core</code> package.
</blockquote>
<h4 appAnchor id="retrieving-instances"><span>Retrieving instances</span></h4>
<p>The <code>ModuleRef</code> instance (hereafter we&#39;ll refer to it as the <strong>module reference</strong>) has a <code>get()</code> method. By default, this method returns a provider, controller, or injectable (e.g., guard, interceptor, etc.) that was registered and has been instantiated in the <em>current module</em> using its injection token/class name. If the instance is not found, an exception will be raised.</p>

<span class="filename">
  {{ 'cats.service' | extension: appa0b74c496a79b4e84189e2cbecdc07a7b4a68045.isJsActive }}
<app-tabs #appa0b74c496a79b4e84189e2cbecdc07a7b4a68045></app-tabs>
</span><pre [class.hide]="appa0b74c496a79b4e84189e2cbecdc07a7b4a68045.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  private service: Service;
  constructor(private moduleRef: ModuleRef) &#123;&#125;

  onModuleInit() &#123;
    this.service = this.moduleRef.get(Service);
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!appa0b74c496a79b4e84189e2cbecdc07a7b4a68045.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  onModuleInit() &#123;
    this.service = this.moduleRef.get(Service);
  &#125;
&#125;
</code></pre><blockquote class="
warning "><strong>Warning</strong> You can&#39;t retrieve scoped providers (transient or request-scoped) with the <code>get()</code> method. Instead, use the technique described <a href="https://docs.nestjs.com/fundamentals/module-ref#resolving-scoped-providers">below</a>. Learn how to control scopes <a routerLink="/fundamentals/injection-scopes">here</a>.
</blockquote>
<p>To retrieve a provider from the global context (for example, if the provider has been injected in a different module), pass the <code>{{ &#39;{&#39; }} strict: false {{ &#39;}&#39; }}</code> option as a second argument to <code>get()</code>.</p>
<pre><code class="language-typescript">
this.moduleRef.get(Service, &#123; strict: false &#125;);
</code></pre>
<h4 appAnchor id="resolving-scoped-providers"><span>Resolving scoped providers</span></h4>
<p>To dynamically resolve a scoped provider (transient or request-scoped), use the <code>resolve()</code> method, passing the provider&#39;s injection token as an argument.</p>

<span class="filename">
  {{ 'cats.service' | extension: app3ee109092830d74deae5a09e831bc1a23f6aca31.isJsActive }}
<app-tabs #app3ee109092830d74deae5a09e831bc1a23f6aca31></app-tabs>
</span><pre [class.hide]="app3ee109092830d74deae5a09e831bc1a23f6aca31.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  private transientService: TransientService;
  constructor(private moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    this.transientService = await this.moduleRef.resolve(TransientService);
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!app3ee109092830d74deae5a09e831bc1a23f6aca31.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    this.transientService = await this.moduleRef.resolve(TransientService);
  &#125;
&#125;
</code></pre><p>The <code>resolve()</code> method returns a unique instance of the provider, from its own <strong>DI container sub-tree</strong>. Each sub-tree has a unique <strong>context identifier</strong>. Thus, if you call this method more than once and compare instance references, you will see that they are not equal.</p>

<span class="filename">
  {{ 'cats.service' | extension: app384f56d618c33c77ea60fceb93417695e9275001.isJsActive }}
<app-tabs #app384f56d618c33c77ea60fceb93417695e9275001></app-tabs>
</span><pre [class.hide]="app384f56d618c33c77ea60fceb93417695e9275001.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  constructor(private moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService),
      this.moduleRef.resolve(TransientService),
    ]);
    console.log(transientServices[0] === transientServices[1]); // false
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!app384f56d618c33c77ea60fceb93417695e9275001.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService),
      this.moduleRef.resolve(TransientService),
    ]);
    console.log(transientServices[0] === transientServices[1]); // false
  &#125;
&#125;
</code></pre><p>To generate a single instance across multiple <code>resolve()</code> calls, and ensure they share the same generated DI container sub-tree, you can pass a context identifier to the <code>resolve()</code> method. Use the <code>ContextIdFactory</code> class to generate a context identifier. This class provides a <code>create()</code> method that returns an appropriate unique identifier.</p>

<span class="filename">
  {{ 'cats.service' | extension: app85cd1bacc42ad12459e3b8d6360364f309a494ca.isJsActive }}
<app-tabs #app85cd1bacc42ad12459e3b8d6360364f309a494ca></app-tabs>
</span><pre [class.hide]="app85cd1bacc42ad12459e3b8d6360364f309a494ca.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  constructor(private moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    const contextId = ContextIdFactory.create();
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService, contextId),
      this.moduleRef.resolve(TransientService, contextId),
    ]);
    console.log(transientServices[0] === transientServices[1]); // true
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!app85cd1bacc42ad12459e3b8d6360364f309a494ca.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    const contextId = ContextIdFactory.create();
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService, contextId),
      this.moduleRef.resolve(TransientService, contextId),
    ]);
    console.log(transientServices[0] === transientServices[1]); // true
  &#125;
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>ContextIdFactory</code> class is imported from the <code>@nestjs/core</code> package.
</blockquote>
<h4 appAnchor id="registering-request-provider"><span>Registering <code>REQUEST</code> provider</span></h4>
<p>Manually generated context identifiers (with <code>ContextIdFactory.create()</code>) represent DI sub-trees in which <code>REQUEST</code> provider is <code>undefined</code> as they are not instantiated and managed by the Nest dependency injection system.</p>
<p>To register a custom <code>REQUEST</code> object for a manually created DI sub-tree, use the <code>ModuleRef#registerRequestByContextId()</code> method, as follows:</p>
<pre><code class="language-typescript">
const contextId = ContextIdFactory.create();
this.moduleRef.registerRequestByContextId(/* YOUR_REQUEST_OBJECT */, contextId);
</code></pre>
<h4 appAnchor id="getting-current-sub-tree"><span>Getting current sub-tree</span></h4>
<p>Occasionally, you may want to resolve an instance of a request-scoped provider within a <strong>request context</strong>. Let&#39;s say that <code>CatsService</code> is request-scoped and you want to resolve the <code>CatsRepository</code> instance which is also marked as a request-scoped provider. In order to share the same DI container sub-tree, you must obtain the current context identifier instead of generating a new one (e.g., with the <code>ContextIdFactory.create()</code> function, as shown above). To obtain the current context identifier, start by injecting the request object using <code>@Inject()</code> decorator.</p>

<span class="filename">
  {{ 'cats.service' | extension: appce981a9fffe21cb70806666473ddbcfee45c56da.isJsActive }}
<app-tabs #appce981a9fffe21cb70806666473ddbcfee45c56da></app-tabs>
</span><pre [class.hide]="appce981a9fffe21cb70806666473ddbcfee45c56da.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService &#123;
  constructor(
    @Inject(REQUEST) private request: Record&lt;string, unknown&gt;,
  ) &#123;&#125;
&#125;
</code></pre>
<pre [class.hide]="!appce981a9fffe21cb70806666473ddbcfee45c56da.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(REQUEST)
export class CatsService &#123;
  constructor(request) &#123;
    this.request = request;
  &#125;
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> Learn more about the request provider <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/fundamentals/injection-scopes#request-provider">here</a>.
</blockquote>
<p>Now, use the <code>getByRequest()</code> method of the <code>ContextIdFactory</code> class to create a context id based on the request object, and pass this to the <code>resolve()</code> call:</p>
<pre><code class="language-typescript">
const contextId = ContextIdFactory.getByRequest(this.request);
const catsRepository = await this.moduleRef.resolve(CatsRepository, contextId);
</code></pre>
<h4 appAnchor id="instantiating-custom-classes-dynamically"><span>Instantiating custom classes dynamically</span></h4>
<p>To dynamically instantiate a class that <strong>wasn&#39;t previously registered</strong> as a <strong>provider</strong>, use the module reference&#39;s <code>create()</code> method.</p>

<span class="filename">
  {{ 'cats.service' | extension: app2d52ed8f0cf79b7a7bcddf6fde4667eccd7ef353.isJsActive }}
<app-tabs #app2d52ed8f0cf79b7a7bcddf6fde4667eccd7ef353></app-tabs>
</span><pre [class.hide]="app2d52ed8f0cf79b7a7bcddf6fde4667eccd7ef353.isJsActive"><code class="language-typescript">
@Injectable()
export class CatsService implements OnModuleInit &#123;
  private catsFactory: CatsFactory;
  constructor(private moduleRef: ModuleRef) &#123;&#125;

  async onModuleInit() &#123;
    this.catsFactory = await this.moduleRef.create(CatsFactory);
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!app2d52ed8f0cf79b7a7bcddf6fde4667eccd7ef353.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(ModuleRef)
export class CatsService &#123;
  constructor(moduleRef) &#123;
    this.moduleRef = moduleRef;
  &#125;

  async onModuleInit() &#123;
    this.catsFactory = await this.moduleRef.create(CatsFactory);
  &#125;
&#125;
</code></pre><p>This technique enables you to conditionally instantiate different classes outside of the framework container.</p>
<p><app-banner-devtools></app-banner-devtools></p>

</div>

