
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/lifecycle-events.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="lifecycle-events">Lifecycle Events</h3>
<p>A Nest application, as well as every application element, has a lifecycle managed by Nest. Nest provides <strong>lifecycle hooks</strong> that give visibility into key lifecycle events, and the ability to act (run registered code on your modules, providers or controllers) when they occur.</p>
<h4 appAnchor id="lifecycle-sequence"><span>Lifecycle sequence</span></h4>
<p>The following diagram depicts the sequence of key application lifecycle events, from the time the application is bootstrapped until the node process exits. We can divide the overall lifecycle into three phases: <strong>initializing</strong>, <strong>running</strong> and <strong>terminating</strong>. Using this lifecycle, you can plan for appropriate initialization of modules and services, manage active connections, and gracefully shutdown your application when it receives a termination signal.</p>
<figure><img class="illustrative-image" src="/assets/lifecycle-events.png" /></figure>

<h4 appAnchor id="lifecycle-events-1"><span>Lifecycle events</span></h4>
<p>Lifecycle events happen during application bootstrapping and shutdown. Nest calls registered lifecycle hook methods on modules, providers and controllers at each of the following lifecycle events (<strong>shutdown hooks</strong> need to be enabled first, as described <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/fundamentals/lifecycle-events#application-shutdown">below</a>). As shown in the diagram above, Nest also calls the appropriate underlying methods to begin listening for connections, and to stop listening for connections.</p>
<p>In the following table, <code>onModuleDestroy</code>, <code>beforeApplicationShutdown</code> and <code>onApplicationShutdown</code> are only triggered if you explicitly call <code>app.close()</code> or if the process receives a special system signal (such as SIGTERM) and you have correctly called <code>enableShutdownHooks</code> at application bootstrap (see below <strong>Application shutdown</strong> part).</p>
<table>
<thead>
<tr>
<th>Lifecycle hook method</th>
<th>Lifecycle event triggering the hook method call</th>
</tr>
</thead>
<tbody><tr>
<td><code>onModuleInit()</code></td>
<td>Called once the host module&#39;s dependencies have been resolved.</td>
</tr>
<tr>
<td><code>onApplicationBootstrap()</code></td>
<td>Called once all modules have been initialized, but before listening for connections.</td>
</tr>
<tr>
<td><code>onModuleDestroy()</code>*</td>
<td>Called after a termination signal (e.g., <code>SIGTERM</code>) has been received.</td>
</tr>
<tr>
<td><code>beforeApplicationShutdown()</code>*</td>
<td>Called after all <code>onModuleDestroy()</code> handlers have completed (Promises resolved or rejected);<br />once complete (Promises resolved or rejected), all existing connections will be closed (<code>app.close()</code> called).</td>
</tr>
<tr>
<td><code>onApplicationShutdown()</code>*</td>
<td>Called after connections close (<code>app.close()</code> resolves).</td>
</tr>
</tbody></table>
<p>* For these events, if you&#39;re not calling <code>app.close()</code> explicitly, you must opt-in to make them work with system signals such as <code>SIGTERM</code>. See <a href="fundamentals/lifecycle-events#application-shutdown">Application shutdown</a> below.</p>
<blockquote class="
warning "><strong>Warning</strong> The lifecycle hooks listed above are not triggered for <strong>request-scoped</strong> classes. Request-scoped classes are not tied to the application lifecycle and their lifespan is unpredictable. They are exclusively created for each request and automatically garbage-collected after the response is sent.
</blockquote>
<blockquote class="
info "><strong>Hint</strong> Execution order of <code>onModuleInit()</code> and <code>onApplicationBootstrap()</code> directly depends on the order of module imports, awaiting the previous hook.
</blockquote>
<h4 appAnchor id="usage"><span>Usage</span></h4>
<p>Each lifecycle hook is represented by an interface. Interfaces are technically optional because they do not exist after TypeScript compilation. Nonetheless, it&#39;s good practice to use them in order to benefit from strong typing and editor tooling. To register a lifecycle hook, implement the appropriate interface. For example, to register a method to be called during module initialization on a particular class (e.g., Controller, Provider or Module), implement the <code>OnModuleInit</code> interface by supplying an <code>onModuleInit()</code> method, as shown below:</p>

<span class="filename">
<app-tabs #app097993bb684948a8ff29966a0bab04ee832a5182></app-tabs>
</span><pre [class.hide]="app097993bb684948a8ff29966a0bab04ee832a5182.isJsActive"><code class="language-typescript">
import &#123; Injectable, OnModuleInit &#125; from &#39;@nestjs/common&#39;;

@Injectable()
export class UsersService implements OnModuleInit &#123;
  onModuleInit() &#123;
    console.log(`The module has been initialized.`);
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!app097993bb684948a8ff29966a0bab04ee832a5182.isJsActive"><code class="language-typescript">
import &#123; Injectable &#125; from &#39;@nestjs/common&#39;;

@Injectable()
export class UsersService &#123;
  onModuleInit() &#123;
    console.log(`The module has been initialized.`);
  &#125;
&#125;
</code></pre><h4 appAnchor id="asynchronous-initialization"><span>Asynchronous initialization</span></h4>
<p>Both the <code>OnModuleInit</code> and <code>OnApplicationBootstrap</code> hooks allow you to defer the application initialization process (return a <code>Promise</code> or mark the method as <code>async</code> and <code>await</code> an asynchronous method completion in the method body).</p>

<span class="filename">
<app-tabs #app1458cd787acd6e5c624ff0b93d6308c62914440b></app-tabs>
</span><pre [class.hide]="app1458cd787acd6e5c624ff0b93d6308c62914440b.isJsActive"><code class="language-typescript">
async onModuleInit(): Promise&lt;void&gt; &#123;
  await this.fetch();
&#125;
</code></pre>
<pre [class.hide]="!app1458cd787acd6e5c624ff0b93d6308c62914440b.isJsActive"><code class="language-typescript">
async onModuleInit() &#123;
  await this.fetch();
&#125;
</code></pre><h4 appAnchor id="application-shutdown"><span>Application shutdown</span></h4>
<p>The <code>onModuleDestroy()</code>, <code>beforeApplicationShutdown()</code> and <code>onApplicationShutdown()</code> hooks are called in the terminating phase (in response to an explicit call to <code>app.close()</code> or upon receipt of system signals such as SIGTERM if opted-in). This feature is often used with <a rel='nofollow' target='_blank' href="https://kubernetes.io/">Kubernetes</a> to manage containers&#39; lifecycles, by <a rel='nofollow' target='_blank' href="https://www.heroku.com/">Heroku</a> for dynos or similar services.</p>
<p>Shutdown hook listeners consume system resources, so they are disabled by default. To use shutdown hooks, you <strong>must enable listeners</strong> by calling <code>enableShutdownHooks()</code>:</p>
<pre><code class="language-typescript">
import &#123; NestFactory &#125; from &#39;@nestjs/core&#39;;
import &#123; AppModule &#125; from &#39;./app.module&#39;;

async function bootstrap() &#123;
  const app = await NestFactory.create(AppModule);

  // Starts listening for shutdown hooks
  app.enableShutdownHooks();

  await app.listen(3000);
&#125;
bootstrap();
</code></pre>
<blockquote class="
warning "><strong>warning</strong> Due to inherent platform limitations, NestJS has limited support for application shutdown hooks on Windows. You can expect <code>SIGINT</code> to work, as well as <code>SIGBREAK</code> and to some extent <code>SIGHUP</code> - <a rel='nofollow' target='_blank' href="https://nodejs.org/api/process.html#process_signal_events">read more</a>. However <code>SIGTERM</code> will never work on Windows because killing a process in the task manager is unconditional, &quot;i.e., there&#39;s no way for an application to detect or prevent it&quot;. Here&#39;s some <a rel='nofollow' target='_blank' href="https://docs.libuv.org/en/v1.x/signal.html">relevant documentation</a> from libuv to learn more about how <code>SIGINT</code>, <code>SIGBREAK</code> and others are handled on Windows. Also, see Node.js documentation of <a rel='nofollow' target='_blank' href="https://nodejs.org/api/process.html#process_signal_events">Process Signal Events</a>
</blockquote>
<blockquote class="
info "><strong>Info</strong> <code>enableShutdownHooks</code> consumes memory by starting listeners. In cases where you are running multiple Nest apps in a single Node process (e.g., when running parallel tests with Jest), Node may complain about excessive listener processes. For this reason, <code>enableShutdownHooks</code> is not enabled by default. Be aware of this condition when you are running multiple instances in a single Node process.
</blockquote>
<p>When the application receives a termination signal it will call any registered <code>onModuleDestroy()</code>, <code>beforeApplicationShutdown()</code>, then <code>onApplicationShutdown()</code> methods (in the sequence described above) with the corresponding signal as the first parameter. If a registered function awaits an asynchronous call (returns a promise), Nest will not continue in the sequence until the promise is resolved or rejected.</p>

<span class="filename">
<app-tabs #appfed0853d309ca0ab7da1be3433c4e8ee3aea0333></app-tabs>
</span><pre [class.hide]="appfed0853d309ca0ab7da1be3433c4e8ee3aea0333.isJsActive"><code class="language-typescript">
@Injectable()
class UsersService implements OnApplicationShutdown &#123;
  onApplicationShutdown(signal: string) &#123;
    console.log(signal); // e.g. &quot;SIGINT&quot;
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!appfed0853d309ca0ab7da1be3433c4e8ee3aea0333.isJsActive"><code class="language-typescript">
@Injectable()
class UsersService implements OnApplicationShutdown &#123;
  onApplicationShutdown(signal) &#123;
    console.log(signal); // e.g. &quot;SIGINT&quot;
  &#125;
&#125;
</code></pre><blockquote class="
info "><strong>Info</strong> Calling <code>app.close()</code> doesn&#39;t terminate the Node process but only triggers the <code>onModuleDestroy()</code> and <code>onApplicationShutdown()</code> hooks, so if there are some intervals, long-running background tasks, etc. the process won&#39;t be automatically terminated.
</blockquote>

</div>

