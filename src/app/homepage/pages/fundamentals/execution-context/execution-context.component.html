
<div class="content" #contentReference>
  <div class="github-links">
    <a
      href="https://github.com/nestjs/docs.nestjs.com/edit/master/content/fundamentals/execution-context.md"
      aria-label="Suggest Edits"
      title="Suggest Edits"
    >
      <i class="fas fa-edit"></i>
    </a>
  </div>
  <h3 id="execution-context">Execution context</h3>
<p>Nest provides several utility classes that help make it easy to write applications that function across multiple application contexts (e.g., Nest HTTP server-based, microservices and WebSockets application contexts). These utilities provide information about the current execution context which can be used to build generic <a routerLink="/guards">guards</a>, <a routerLink="/exception-filters">filters</a>, and <a routerLink="/interceptors">interceptors</a> that can work across a broad set of controllers, methods, and execution contexts.</p>
<p>We cover two such classes in this chapter: <code>ArgumentsHost</code> and <code>ExecutionContext</code>.</p>
<h4 appAnchor id="argumentshost-class"><span>ArgumentsHost class</span></h4>
<p>The <code>ArgumentsHost</code> class provides methods for retrieving the arguments being passed to a handler. It allows choosing the appropriate context (e.g., HTTP, RPC (microservice), or WebSockets) to retrieve the arguments from. The framework provides an instance of <code>ArgumentsHost</code>, typically referenced as a <code>host</code> parameter, in places where you may want to access it. For example, the <code>catch()</code> method of an <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/exception-filters#arguments-host">exception filter</a> is called with an <code>ArgumentsHost</code>instance.</p>
<p><code>ArgumentsHost</code> simply acts as an abstraction over a handler&#39;s arguments. For example, for HTTP server applications (when <code>@nestjs/platform-express</code> is being used), the <code>host</code> object encapsulates Express&#39;s <code>[request, response, next]</code> array, where <code>request</code> is the request object, <code>response</code> is the response object, and <code>next</code> is a function that controls the application&#39;s request-response cycle. On the other hand, for <a routerLink="/graphql/quick-start">GraphQL</a> applications, the <code>host</code> object contains the <code>[root, args, context, info]</code> array.</p>
<h4 appAnchor id="current-application-context"><span>Current application context</span></h4>
<p>When building generic <a routerLink="/guards">guards</a>, <a routerLink="/exception-filters">filters</a>, and <a routerLink="/interceptors">interceptors</a> which are meant to run across multiple application contexts, we need a way to determine the type of application that our method is currently running in. Do this with the <code>getType()</code> method of <code>ArgumentsHost</code>:</p>
<pre><code class="language-typescript">
if (host.getType() === &#39;http&#39;) &#123;
  // do something that is only important in the context of regular HTTP requests (REST)
&#125; else if (host.getType() === &#39;rpc&#39;) &#123;
  // do something that is only important in the context of Microservice requests
&#125; else if (host.getType&lt;GqlContextType&gt;() === &#39;graphql&#39;) &#123;
  // do something that is only important in the context of GraphQL requests
&#125;
</code></pre>
<blockquote class="
info "><strong>Hint</strong> The <code>GqlContextType</code> is imported from the <code>@nestjs/graphql</code> package.
</blockquote>
<p>With the application type available, we can write more generic components, as shown below.</p>
<h4 appAnchor id="host-handler-arguments"><span>Host handler arguments</span></h4>
<p>To retrieve the array of arguments being passed to the handler, one approach is to use the host object&#39;s <code>getArgs()</code> method.</p>
<pre><code class="language-typescript">
const [req, res, next] = host.getArgs();
</code></pre>
<p>You can pluck a particular argument by index using the <code>getArgByIndex()</code> method:</p>
<pre><code class="language-typescript">
const request = host.getArgByIndex(0);
const response = host.getArgByIndex(1);
</code></pre>
<p>In these examples we retrieved the request and response objects by index, which is not typically recommended as it couples the application to a particular execution context. Instead, you can make your code more robust and reusable by using one of the <code>host</code> object&#39;s utility methods to switch to the appropriate application context for your application. The context switch utility methods are shown below.</p>
<pre><code class="language-typescript">
/**
 * Switch context to RPC.
 */
switchToRpc(): RpcArgumentsHost;
/**
 * Switch context to HTTP.
 */
switchToHttp(): HttpArgumentsHost;
/**
 * Switch context to WebSockets.
 */
switchToWs(): WsArgumentsHost;
</code></pre>
<p>Let&#39;s rewrite the previous example using the <code>switchToHttp()</code> method. The <code>host.switchToHttp()</code> helper call returns an <code>HttpArgumentsHost</code> object that is appropriate for the HTTP application context. The <code>HttpArgumentsHost</code> object has two useful methods we can use to extract the desired objects. We also use the Express type assertions in this case to return native Express typed objects:</p>
<pre><code class="language-typescript">
const ctx = host.switchToHttp();
const request = ctx.getRequest&lt;Request&gt;();
const response = ctx.getResponse&lt;Response&gt;();
</code></pre>
<p>Similarly <code>WsArgumentsHost</code> and <code>RpcArgumentsHost</code> have methods to return appropriate objects in the microservices and WebSockets contexts. Here are the methods for <code>WsArgumentsHost</code>:</p>
<pre><code class="language-typescript">
export interface WsArgumentsHost &#123;
  /**
   * Returns the data object.
   */
  getData&lt;T&gt;(): T;
  /**
   * Returns the client object.
   */
  getClient&lt;T&gt;(): T;
&#125;
</code></pre>
<p>Following are the methods for <code>RpcArgumentsHost</code>:</p>
<pre><code class="language-typescript">
export interface RpcArgumentsHost &#123;
  /**
   * Returns the data object.
   */
  getData&lt;T&gt;(): T;

  /**
   * Returns the context object.
   */
  getContext&lt;T&gt;(): T;
&#125;
</code></pre>
<h4 appAnchor id="executioncontext-class"><span>ExecutionContext class</span></h4>
<p><code>ExecutionContext</code> extends <code>ArgumentsHost</code>, providing additional details about the current execution process. Like <code>ArgumentsHost</code>, Nest provides an instance of <code>ExecutionContext</code> in places you may need it, such as in the <code>canActivate()</code> method of a <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/guards#execution-context">guard</a> and the <code>intercept()</code> method of an <a rel='nofollow' target='_blank' href="https://docs.nestjs.com/interceptors#execution-context">interceptor</a>. It provides the following methods:</p>
<pre><code class="language-typescript">
export interface ExecutionContext extends ArgumentsHost &#123;
  /**
   * Returns the type of the controller class which the current handler belongs to.
   */
  getClass&lt;T&gt;(): Type&lt;T&gt;;
  /**
   * Returns a reference to the handler (method) that will be invoked next in the
   * request pipeline.
   */
  getHandler(): Function;
&#125;
</code></pre>
<p>The <code>getHandler()</code> method returns a reference to the handler about to be invoked. The <code>getClass()</code> method returns the type of the <code>Controller</code> class which this particular handler belongs to. For example, in an HTTP context, if the currently processed request is a <code>POST</code> request, bound to the <code>create()</code> method on the <code>CatsController</code>, <code>getHandler()</code> returns a reference to the <code>create()</code> method and <code>getClass()</code> returns the <code>CatsController</code> <strong>class</strong> (not instance).</p>
<pre><code class="language-typescript">
const methodKey = ctx.getHandler().name; // &quot;create&quot;
const className = ctx.getClass().name; // &quot;CatsController&quot;
</code></pre>
<p>The ability to access references to both the current class and handler method provides great flexibility. Most importantly, it gives us the opportunity to access the metadata set through either decorators created via <code>Reflector#createDecorator</code> or the built-in <code>@SetMetadata()</code> decorator from within guards or interceptors. We cover this use case below.</p>
<p><app-banner-enterprise></app-banner-enterprise></p>
<h4 appAnchor id="reflection-and-metadata"><span>Reflection and metadata</span></h4>
<p>Nest provides the ability to attach <strong>custom metadata</strong> to route handlers through decorators created via <code>Reflector#createDecorator</code> method, and the built-in <code>@SetMetadata()</code> decorator. In this section, let&#39;s compare the two approaches and see how to access the metadata from within a guard or interceptor.</p>
<p>To create strongly-typed decorators using <code>Reflector#createDecorator</code>, we need to specify the type argument. For example, let&#39;s create a <code>Roles</code> decorator that takes an array of strings as an argument.</p>

<span class="filename">
  {{ 'roles.decorator' | extension: app16b391a92df79cee540dcd787d3ee130833dabce.isJsActive }}
<app-tabs #app16b391a92df79cee540dcd787d3ee130833dabce></app-tabs>
</span><pre><code class="language-ts">
import &#123; Reflector &#125; from &#39;@nestjs/core&#39;;

export const Roles = Reflector.createDecorator&lt;string[]&gt;();
</code></pre><p>The <code>Roles</code> decorator here is a function that takes a single argument of type <code>string[]</code>.</p>
<p>Now, to use this decorator, we simply annotate the handler with it:</p>

<span class="filename">
  {{ 'cats.controller' | extension: app4208e3ae09ccd972cfa3fbfc1aa86e25b60664eb.isJsActive }}
<app-tabs #app4208e3ae09ccd972cfa3fbfc1aa86e25b60664eb></app-tabs>
</span><pre [class.hide]="app4208e3ae09ccd972cfa3fbfc1aa86e25b60664eb.isJsActive"><code class="language-typescript">
@Post()
@Roles([&#39;admin&#39;])
async create(@Body() createCatDto: CreateCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;
</code></pre>
<pre [class.hide]="!app4208e3ae09ccd972cfa3fbfc1aa86e25b60664eb.isJsActive"><code class="language-typescript">
@Post()
@Roles([&#39;admin&#39;])
@Bind(Body())
async create(createCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;
</code></pre><p>Here we&#39;ve attached the <code>Roles</code> decorator metadata to the <code>create()</code> method, indicating that only users with the <code>admin</code> role should be allowed to access this route.</p>
<p>To access the route&#39;s role(s) (custom metadata), we&#39;ll use the <code>Reflector</code> helper class again. <code>Reflector</code> can be injected into a class in the normal way:</p>

<span class="filename">
  {{ 'roles.guard' | extension: app93dc9e9f048c0a27e4c1864b95a33bd0d4c969be.isJsActive }}
<app-tabs #app93dc9e9f048c0a27e4c1864b95a33bd0d4c969be></app-tabs>
</span><pre [class.hide]="app93dc9e9f048c0a27e4c1864b95a33bd0d4c969be.isJsActive"><code class="language-typescript">
@Injectable()
export class RolesGuard &#123;
  constructor(private reflector: Reflector) &#123;&#125;
&#125;
</code></pre>
<pre [class.hide]="!app93dc9e9f048c0a27e4c1864b95a33bd0d4c969be.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(Reflector)
export class CatsService &#123;
  constructor(reflector) &#123;
    this.reflector = reflector;
  &#125;
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>Reflector</code> class is imported from the <code>@nestjs/core</code> package.
</blockquote>
<p>Now, to read the handler metadata, use the <code>get()</code> method:</p>
<pre><code class="language-typescript">
const roles = this.reflector.get(Roles, context.getHandler());
</code></pre>
<p>The <code>Reflector#get</code> method allows us to easily access the metadata by passing in two arguments: a decorator reference and a <strong>context</strong> (decorator target) to retrieve the metadata from. In this example, the specified <strong>decorator</strong> is <code>Roles</code> (refer back to the <code>roles.decorator.ts</code> file above). The context is provided by the call to <code>context.getHandler()</code>, which results in extracting the metadata for the currently processed route handler. Remember, <code>getHandler()</code> gives us a <strong>reference</strong> to the route handler function.</p>
<p>Alternatively, we may organize our controller by applying metadata at the controller level, applying to all routes in the controller class.</p>

<span class="filename">
  {{ 'cats.controller' | extension: appff6dc513babf92635de97fec425eb78dffefa861.isJsActive }}
<app-tabs #appff6dc513babf92635de97fec425eb78dffefa861></app-tabs>
</span><pre [class.hide]="appff6dc513babf92635de97fec425eb78dffefa861.isJsActive"><code class="language-typescript">
@Roles([&#39;admin&#39;])
@Controller(&#39;cats&#39;)
export class CatsController &#123;&#125;
</code></pre>
<pre [class.hide]="!appff6dc513babf92635de97fec425eb78dffefa861.isJsActive"><code class="language-typescript">
@Roles([&#39;admin&#39;])
@Controller(&#39;cats&#39;)
export class CatsController &#123;&#125;
</code></pre><p>In this case, to extract controller metadata, we pass <code>context.getClass()</code> as the second argument (to provide the controller class as the context for metadata extraction) instead of <code>context.getHandler()</code>:</p>

<span class="filename">
  {{ 'roles.guard' | extension: appc90fce3c5e16a1259dc6068d85c7bfd4759dbf07.isJsActive }}
<app-tabs #appc90fce3c5e16a1259dc6068d85c7bfd4759dbf07></app-tabs>
</span><pre><code class="language-typescript">
const roles = this.reflector.get(Roles, context.getClass());
</code></pre><p>Given the ability to provide metadata at multiple levels, you may need to extract and merge metadata from several contexts. The <code>Reflector</code> class provides two utility methods used to help with this. These methods extract <strong>both</strong> controller and method metadata at once, and combine them in different ways.</p>
<p>Consider the following scenario, where you&#39;ve supplied <code>Roles</code> metadata at both levels.</p>

<span class="filename">
  {{ 'cats.controller' | extension: app613b469a1fa163d592f7e554b6fd31ef6bd5b6c4.isJsActive }}
<app-tabs #app613b469a1fa163d592f7e554b6fd31ef6bd5b6c4></app-tabs>
</span><pre [class.hide]="app613b469a1fa163d592f7e554b6fd31ef6bd5b6c4.isJsActive"><code class="language-typescript">
@Roles([&#39;user&#39;])
@Controller(&#39;cats&#39;)
export class CatsController &#123;
  @Post()
  @Roles([&#39;admin&#39;])
  async create(@Body() createCatDto: CreateCatDto) &#123;
    this.catsService.create(createCatDto);
  &#125;
&#125;
</code></pre>
<pre [class.hide]="!app613b469a1fa163d592f7e554b6fd31ef6bd5b6c4.isJsActive"><code class="language-typescript">
@Roles([&#39;user&#39;])
@Controller(&#39;cats&#39;)
export class CatsController &#123;&#125;
  @Post()
  @Roles([&#39;admin&#39;])
  @Bind(Body())
  async create(createCatDto) &#123;
    this.catsService.create(createCatDto);
  &#125;
&#125;
</code></pre><p>If your intent is to specify <code>&#39;user&#39;</code> as the default role, and override it selectively for certain methods, you would probably use the <code>getAllAndOverride()</code> method.</p>
<pre><code class="language-typescript">
const roles = this.reflector.getAllAndOverride(Roles, [context.getHandler(), context.getClass()]);
</code></pre>
<p>A guard with this code, running in the context of the <code>create()</code> method, with the above metadata, would result in <code>roles</code> containing <code>[&#39;admin&#39;]</code>.</p>
<p>To get metadata for both and merge it (this method merges both arrays and objects), use the <code>getAllAndMerge()</code> method:</p>
<pre><code class="language-typescript">
const roles = this.reflector.getAllAndMerge(Roles, [context.getHandler(), context.getClass()]);
</code></pre>
<p>This would result in <code>roles</code> containing <code>[&#39;user&#39;, &#39;admin&#39;]</code>.</p>
<p>For both of these merge methods, you pass the metadata key as the first argument, and an array of metadata target contexts (i.e., calls to the <code>getHandler()</code> and/or <code>getClass()</code> methods) as the second argument.</p>
<h4 appAnchor id="low-level-approach"><span>Low-level approach</span></h4>
<p>As mentioned earlier, instead of using <code>Reflector#createDecorator</code>, you can also use the built-in <code>@SetMetadata()</code> decorator to attach metadata to a handler.</p>

<span class="filename">
  {{ 'cats.controller' | extension: app835a3d228667a1838da7705b2a92cc7c9cb3a0f4.isJsActive }}
<app-tabs #app835a3d228667a1838da7705b2a92cc7c9cb3a0f4></app-tabs>
</span><pre [class.hide]="app835a3d228667a1838da7705b2a92cc7c9cb3a0f4.isJsActive"><code class="language-typescript">
@Post()
@SetMetadata(&#39;roles&#39;, [&#39;admin&#39;])
async create(@Body() createCatDto: CreateCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;
</code></pre>
<pre [class.hide]="!app835a3d228667a1838da7705b2a92cc7c9cb3a0f4.isJsActive"><code class="language-typescript">
@Post()
@SetMetadata(&#39;roles&#39;, [&#39;admin&#39;])
@Bind(Body())
async create(createCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>@SetMetadata()</code> decorator is imported from the <code>@nestjs/common</code> package.
</blockquote>
<p>With the construction above, we attached the <code>roles</code> metadata (<code>roles</code> is a metadata key and <code>[&#39;admin&#39;]</code> is the associated value) to the <code>create()</code> method. While this works, it&#39;s not good practice to use <code>@SetMetadata()</code> directly in your routes. Instead, you can create your own decorators, as shown below:</p>

<span class="filename">
  {{ 'roles.decorator' | extension: appc24bd82b16ceee35f282a95fc3f1ccf67994ff2a.isJsActive }}
<app-tabs #appc24bd82b16ceee35f282a95fc3f1ccf67994ff2a></app-tabs>
</span><pre [class.hide]="appc24bd82b16ceee35f282a95fc3f1ccf67994ff2a.isJsActive"><code class="language-typescript">
import &#123; SetMetadata &#125; from &#39;@nestjs/common&#39;;

export const Roles = (...roles: string[]) =&gt; SetMetadata(&#39;roles&#39;, roles);
</code></pre>
<pre [class.hide]="!appc24bd82b16ceee35f282a95fc3f1ccf67994ff2a.isJsActive"><code class="language-typescript">
import &#123; SetMetadata &#125; from &#39;@nestjs/common&#39;;

export const Roles = (...roles) =&gt; SetMetadata(&#39;roles&#39;, roles);
</code></pre><p>This approach is much cleaner and more readable, and somewhat resembles the <code>Reflector#createDecorator</code> approach. The difference is that with <code>@SetMetadata</code> you have more control over the metadata key and value, and also can create decorators that take more than one argument.</p>
<p>Now that we have a custom <code>@Roles()</code> decorator, we can use it to decorate the <code>create()</code> method.</p>

<span class="filename">
  {{ 'cats.controller' | extension: app5712de62aceb87251c336ccdd2f1af30ec93f6c7.isJsActive }}
<app-tabs #app5712de62aceb87251c336ccdd2f1af30ec93f6c7></app-tabs>
</span><pre [class.hide]="app5712de62aceb87251c336ccdd2f1af30ec93f6c7.isJsActive"><code class="language-typescript">
@Post()
@Roles(&#39;admin&#39;)
async create(@Body() createCatDto: CreateCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;
</code></pre>
<pre [class.hide]="!app5712de62aceb87251c336ccdd2f1af30ec93f6c7.isJsActive"><code class="language-typescript">
@Post()
@Roles(&#39;admin&#39;)
@Bind(Body())
async create(createCatDto) &#123;
  this.catsService.create(createCatDto);
&#125;
</code></pre><p>To access the route&#39;s role(s) (custom metadata), we&#39;ll use the <code>Reflector</code> helper class again:</p>

<span class="filename">
  {{ 'roles.guard' | extension: appe65e96c406f43c1520afaa8d33c24c7a167e0603.isJsActive }}
<app-tabs #appe65e96c406f43c1520afaa8d33c24c7a167e0603></app-tabs>
</span><pre [class.hide]="appe65e96c406f43c1520afaa8d33c24c7a167e0603.isJsActive"><code class="language-typescript">
@Injectable()
export class RolesGuard &#123;
  constructor(private reflector: Reflector) &#123;&#125;
&#125;
</code></pre>
<pre [class.hide]="!appe65e96c406f43c1520afaa8d33c24c7a167e0603.isJsActive"><code class="language-typescript">
@Injectable()
@Dependencies(Reflector)
export class CatsService &#123;
  constructor(reflector) &#123;
    this.reflector = reflector;
  &#125;
&#125;
</code></pre><blockquote class="
info "><strong>Hint</strong> The <code>Reflector</code> class is imported from the <code>@nestjs/core</code> package.
</blockquote>
<p>Now, to read the handler metadata, use the <code>get()</code> method.</p>
<pre><code class="language-typescript">
const roles = this.reflector.get&lt;string[]&gt;(&#39;roles&#39;, context.getHandler());
</code></pre>
<p>Here instead of passing a decorator reference, we pass the metadata <strong>key</strong> as the first argument (which in our case is <code>&#39;roles&#39;</code>). Everything else remains the same as in the <code>Reflector#createDecorator</code> example.</p>

</div>

